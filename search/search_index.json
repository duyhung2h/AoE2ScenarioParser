{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"AoE2Scenario Parser documentation \u00b6 This is the documentation page for the AoE2ScenarioParser project. Which is used for editing parts of an aoe2scenario file from Age of Empires 2 Definitive Edition outside the in-game editor.","title":"About"},{"location":"#aoe2scenario-parser-documentation","text":"This is the documentation page for the AoE2ScenarioParser project. Which is used for editing parts of an aoe2scenario file from Age of Empires 2 Definitive Edition outside the in-game editor.","title":"AoE2Scenario Parser documentation"},{"location":"api-doc/","text":"This is the API doc page :) \u00b6 Test :)","title":"This is the API doc page :)"},{"location":"api-doc/#this-is-the-api-doc-page","text":"Test :)","title":"This is the API doc page :)"},{"location":"getting_started/","text":"Getting started \u00b6 Once you have installed the library the fun can begin! To get started import the library in your python project like so: 1 from AoE2ScenarioParser.scenarios.aoe2_de_scenario import AoE2DEScenario Define the file you will be reading from and where you will be writing your new file to. Where to find your scenario files The scenarios can usually be found here: C:\\Users\\<USERNAME>\\Games\\Age of Empires 2 DE\\<STEAMID>\\resources\\_common\\scenario The STEAMID folder is your steam ID and looks something like: 12345678901234567 1 2 input_path = \"File/Path/To/Your/Input/kFile.aoe2scenario\" output_path = \"File/Path/To/Your/Output/File.aoe2scenario\" Do not overwrite your source scenario It is recommended to not overwrite the file you will be reading for backup reasons. Now create the Scenario object with the filename as parameter. 1 scenario = AoE2DEScenario . from_file ( input_path ) Managers \u00b6 You can now edit to your heart's content. Every aspect of the scenario is seperated in managers. Not all parts are currently supported. The following list shows the current support and use of all available managers: Manager Description trigger_manager The trigger manager is used for creating, editing and removing Triggers, Conditions, Effects and Variables. unit_manager The unit manager is used for creating, editing and removing Units. This includes buildings and heroes etc. map_manager The map manager is used for changing terrain, elevation or simply getting coordinates for certain types. player_manager The player manager is used to edit player attributes such as civs, starting age, diplomacy, disables etc. xs_manager The XS manager is used to store XS in a script_call effect to make it easily transferable in Multiplayer You can access all managers like so: 1 2 3 4 5 scenario = AoE2DEScenario . from_file ( input_path ) trigger_manager = scenario . trigger_manager unit_manager = scenario . unit_manager # etc... After you're done editing, you can save your work and write it to an aoe2scenario file: 1 scenario . write_to_file ( output_path )","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"Once you have installed the library the fun can begin! To get started import the library in your python project like so: 1 from AoE2ScenarioParser.scenarios.aoe2_de_scenario import AoE2DEScenario Define the file you will be reading from and where you will be writing your new file to. Where to find your scenario files The scenarios can usually be found here: C:\\Users\\<USERNAME>\\Games\\Age of Empires 2 DE\\<STEAMID>\\resources\\_common\\scenario The STEAMID folder is your steam ID and looks something like: 12345678901234567 1 2 input_path = \"File/Path/To/Your/Input/kFile.aoe2scenario\" output_path = \"File/Path/To/Your/Output/File.aoe2scenario\" Do not overwrite your source scenario It is recommended to not overwrite the file you will be reading for backup reasons. Now create the Scenario object with the filename as parameter. 1 scenario = AoE2DEScenario . from_file ( input_path )","title":"Getting started"},{"location":"getting_started/#managers","text":"You can now edit to your heart's content. Every aspect of the scenario is seperated in managers. Not all parts are currently supported. The following list shows the current support and use of all available managers: Manager Description trigger_manager The trigger manager is used for creating, editing and removing Triggers, Conditions, Effects and Variables. unit_manager The unit manager is used for creating, editing and removing Units. This includes buildings and heroes etc. map_manager The map manager is used for changing terrain, elevation or simply getting coordinates for certain types. player_manager The player manager is used to edit player attributes such as civs, starting age, diplomacy, disables etc. xs_manager The XS manager is used to store XS in a script_call effect to make it easily transferable in Multiplayer You can access all managers like so: 1 2 3 4 5 scenario = AoE2DEScenario . from_file ( input_path ) trigger_manager = scenario . trigger_manager unit_manager = scenario . unit_manager # etc... After you're done editing, you can save your work and write it to an aoe2scenario file: 1 scenario . write_to_file ( output_path )","title":"Managers"},{"location":"hello_world/","text":"Hello World Example \u00b6 Intro \u00b6 With the information from the getting started page, we can make a \" Hello World \" example. We'll read a scenario, add a trigger, some units and edit some terrain and write it back to a new scenario. This \"hello world\" example assumes you've installed an editor. A great editor (IDE) is PyCharm ( Download Community Edition )) Step by step \u00b6 1. Create the scenario \u00b6 Create an empty scenario in the editor and save it as \"hello world\" 2. Setup the project \u00b6 Create a new project and file (in PyCharm). Name the file hello_world.py , and copy the code below into hello_world.py 1 2 3 4 5 6 7 from AoE2ScenarioParser.scenarios.aoe2_de_scenario import AoE2DEScenario # The path to your scenario folder input_folder = \"C:/path/to/your/scenario/folder/\" # The scenario object. scenario = AoE2DEScenario . from_file ( input_folder + \"hello world.aoe2scenario\" ) 3. Getting the scenario path \u00b6 Go to the \"Load Scenario\" menu in-game (Single Player Editors) Copy the path that is opened when clicking the \"Open Scenario Folder\" button (Bottom right) Paste the folder path in the input_folder string Folder separators If you use \\ to separate folders, use 2 per folder ( c:\\\\folder\\\\folder\\\\ ) If you use / to separate folders, 1 is enough ( c:/folder/folder/ ) Remember to add a / or \\\\ at the end of the string too 4. Test if it works \u00b6 Run the python code by pressing Ctrl + Shift + F10 Executing python code in PyCharm Ctrl + Shift + F10 executes the current file in PyCharm. More info here . You should get a console output that looks like this: 1 2 3 4 5 6 7 8 9 10 11 Reading file: 'YOUR FILE PATH' Reading scenario file finished successfully. ############### Attributes ############### >>> Game version: 'DE' >>> Scenario version: 1.43 ########################################## Loading scenario structure finished successfully. Parsing scenario file... \u2714 FileHeader \u2714 DataHeader ... 5. Adding a trigger \u00b6 Now let's add a trigger with a Display Instructions effect that reads \"Hello World\" Add the following code to hello_world.py 1 2 3 4 5 6 7 8 9 10 # Save reference to the manager, so you don't have to do \"scenario.trigger_manager...\" each time trigger_manager = scenario . trigger_manager # Save the created trigger hello_world_trigger = trigger_manager . add_trigger ( \"Hello World Trigger\" ) # Add display_instructions effect to the new trigger hello_world_trigger . new_effect . display_instructions ( display_time = 11 , message = \"Hello World\" ) Now let's check it out in game. Add the following code: 1 scenario . write_to_file ( input_folder + \"hello world output.aoe2scenario\" ) This will save the changes made to the scenario to a new file specified at the given path. Run the python code by pressing Shift + F10 (rerun the last file) You should see something like this at the end of your console: 1 2 3 4 5 6 ... \u2714 Triggers \u2714 Files File writing finished successfully. File successfully written to: 'YOUR OUTPUT FILE PATH' Process finished with exit code 0 Check out the \"hello world output\" scenario in-game and test it! 6. Adding units \u00b6 Remove the scenario.write_to_file(...) line, we'll add it back later Let's add the unit_manager to the script where we added the trigger manager: 1 unit_manager = scenario . unit_manager Now let's add the code to add some units to the end of the script: 1 2 3 4 5 unit_manager . add_unit ( player = PlayerId . ONE , unit_const = UnitInfo . MILITIA . ID , x = 15 , y = 12 ) unit_manager . add_unit ( player = PlayerId . ONE , unit_const = UnitInfo . MAN_AT_ARMS . ID , x = 15 , y = 13 ) unit_manager . add_unit ( player = PlayerId . ONE , unit_const = UnitInfo . LONG_SWORDSMAN . ID , x = 15 , y = 14 ) unit_manager . add_unit ( player = PlayerId . ONE , unit_const = UnitInfo . TWO_HANDED_SWORDSMAN . ID , x = 15 , y = 15 ) unit_manager . add_unit ( player = PlayerId . ONE , unit_const = UnitInfo . CHAMPION . ID , x = 15 , y = 16 ) Take a look at the code, maybe you can see what it does? We add one unit per unit from the militia line to the editor, one per tile. Note These units are placed using whole numbers (called: integers, x=15, y=12 ), if you want units to spawn in the middle of a tile, use .5 after the integer, like so: x=15.5, y=12.5 You can also see the above code uses PlayerId and UnitInfo objects. 1 2 PlayerId.ONE # The number representing player one (1) UnitInfo.MILITIA.ID # The number representing a militia unit (74) Datasets These are datasets, A Dataset is an Enum Class that contains the constants used by the game like unit IDs, etc. These are essential to producing a scenario. Read more about them here . Let's import the datasets using the code below. Add these lines to the top of your file. 1 2 from AoE2ScenarioParser.datasets.players import PlayerId from AoE2ScenarioParser.datasets.units import UnitInfo 7. Changing the map \u00b6 And now as final change let's add a hill and change the size of the map. First add the map_manager : 1 map_manager = scenario . map_manager Place it with the unit_manager and the trigger_manager Now let's add the code for the hill: 1 map_manager . set_elevation ( elevation = 3 , x1 = 10 , y1 = 10 , x2 = 20 , y2 = 20 ) The in-game max elevation is 7, that's equivelant to elevation=6 in the parser. This is because elevation=0 is elevation 1 in the editor. Using the parser you can go as large as you want, although above ~20 without UHD and ~15 with UHD the camera starts clipping into the hill. And finally let's shrink the map size to 40x40 tiles 1 map_manager . map_size = 40 Max map size limit The limit of a scenario is set to the size of a ludikrous map ( 480x480 ). Going over this limit will cause the game to crash. Now let's add the writing to file back: 1 scenario . write_to_file ( input_folder + \"hello world output.aoe2scenario\" ) Run the python code by pressing Shift + F10 again and check out the scenario! Complete code block \u00b6 Your code should look something like the below block. You can find more examples & explanation on the cheatsheets and the examples page. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from AoE2ScenarioParser.datasets.players import PlayerId from AoE2ScenarioParser.datasets.units import UnitInfo from AoE2ScenarioParser.scenarios.aoe2_de_scenario import AoE2DEScenario # The path to your scenario folder input_folder = \"C:/path/to/your/scenario/folder/\" # The scenario object. scenario = AoE2DEScenario . from_file ( input_folder + \"hello world.aoe2scenario\" ) # Save reference to the manager, so you don't have to do \"scenario.trigger_manager...\" each time trigger_manager = scenario . trigger_manager unit_manager = scenario . unit_manager map_manager = scenario . map_manager # Save the created trigger hello_world_trigger = trigger_manager . add_trigger ( \"Hello World Trigger\" ) # Add display_instructions effect to the new trigger hello_world_trigger . new_effect . display_instructions ( display_time = 11 , message = \"Hello World\" ) unit_manager . add_unit ( player = PlayerId . ONE , unit_const = UnitInfo . MILITIA . ID , x = 15 , y = 12 ) unit_manager . add_unit ( player = PlayerId . ONE , unit_const = UnitInfo . MAN_AT_ARMS . ID , x = 15 , y = 13 ) unit_manager . add_unit ( player = PlayerId . ONE , unit_const = UnitInfo . LONG_SWORDSMAN . ID , x = 15 , y = 14 ) unit_manager . add_unit ( player = PlayerId . ONE , unit_const = UnitInfo . TWO_HANDED_SWORDSMAN . ID , x = 15 , y = 15 ) unit_manager . add_unit ( player = PlayerId . ONE , unit_const = UnitInfo . CHAMPION . ID , x = 15 , y = 16 ) map_manager . set_elevation ( elevation = 3 , x1 = 10 , y1 = 10 , x2 = 20 , y2 = 20 ) map_manager . map_size = 40 scenario . write_to_file ( input_folder + \"hello world output.aoe2scenario\" )","title":"Hello World"},{"location":"hello_world/#hello-world-example","text":"","title":"Hello World Example"},{"location":"hello_world/#intro","text":"With the information from the getting started page, we can make a \" Hello World \" example. We'll read a scenario, add a trigger, some units and edit some terrain and write it back to a new scenario. This \"hello world\" example assumes you've installed an editor. A great editor (IDE) is PyCharm ( Download Community Edition ))","title":"Intro"},{"location":"hello_world/#step-by-step","text":"","title":"Step by step"},{"location":"hello_world/#1-create-the-scenario","text":"Create an empty scenario in the editor and save it as \"hello world\"","title":"1. Create the scenario"},{"location":"hello_world/#2-setup-the-project","text":"Create a new project and file (in PyCharm). Name the file hello_world.py , and copy the code below into hello_world.py 1 2 3 4 5 6 7 from AoE2ScenarioParser.scenarios.aoe2_de_scenario import AoE2DEScenario # The path to your scenario folder input_folder = \"C:/path/to/your/scenario/folder/\" # The scenario object. scenario = AoE2DEScenario . from_file ( input_folder + \"hello world.aoe2scenario\" )","title":"2. Setup the project"},{"location":"hello_world/#3-getting-the-scenario-path","text":"Go to the \"Load Scenario\" menu in-game (Single Player Editors) Copy the path that is opened when clicking the \"Open Scenario Folder\" button (Bottom right) Paste the folder path in the input_folder string Folder separators If you use \\ to separate folders, use 2 per folder ( c:\\\\folder\\\\folder\\\\ ) If you use / to separate folders, 1 is enough ( c:/folder/folder/ ) Remember to add a / or \\\\ at the end of the string too","title":"3. Getting the scenario path"},{"location":"hello_world/#4-test-if-it-works","text":"Run the python code by pressing Ctrl + Shift + F10 Executing python code in PyCharm Ctrl + Shift + F10 executes the current file in PyCharm. More info here . You should get a console output that looks like this: 1 2 3 4 5 6 7 8 9 10 11 Reading file: 'YOUR FILE PATH' Reading scenario file finished successfully. ############### Attributes ############### >>> Game version: 'DE' >>> Scenario version: 1.43 ########################################## Loading scenario structure finished successfully. Parsing scenario file... \u2714 FileHeader \u2714 DataHeader ...","title":"4. Test if it works"},{"location":"hello_world/#5-adding-a-trigger","text":"Now let's add a trigger with a Display Instructions effect that reads \"Hello World\" Add the following code to hello_world.py 1 2 3 4 5 6 7 8 9 10 # Save reference to the manager, so you don't have to do \"scenario.trigger_manager...\" each time trigger_manager = scenario . trigger_manager # Save the created trigger hello_world_trigger = trigger_manager . add_trigger ( \"Hello World Trigger\" ) # Add display_instructions effect to the new trigger hello_world_trigger . new_effect . display_instructions ( display_time = 11 , message = \"Hello World\" ) Now let's check it out in game. Add the following code: 1 scenario . write_to_file ( input_folder + \"hello world output.aoe2scenario\" ) This will save the changes made to the scenario to a new file specified at the given path. Run the python code by pressing Shift + F10 (rerun the last file) You should see something like this at the end of your console: 1 2 3 4 5 6 ... \u2714 Triggers \u2714 Files File writing finished successfully. File successfully written to: 'YOUR OUTPUT FILE PATH' Process finished with exit code 0 Check out the \"hello world output\" scenario in-game and test it!","title":"5. Adding a trigger"},{"location":"hello_world/#6-adding-units","text":"Remove the scenario.write_to_file(...) line, we'll add it back later Let's add the unit_manager to the script where we added the trigger manager: 1 unit_manager = scenario . unit_manager Now let's add the code to add some units to the end of the script: 1 2 3 4 5 unit_manager . add_unit ( player = PlayerId . ONE , unit_const = UnitInfo . MILITIA . ID , x = 15 , y = 12 ) unit_manager . add_unit ( player = PlayerId . ONE , unit_const = UnitInfo . MAN_AT_ARMS . ID , x = 15 , y = 13 ) unit_manager . add_unit ( player = PlayerId . ONE , unit_const = UnitInfo . LONG_SWORDSMAN . ID , x = 15 , y = 14 ) unit_manager . add_unit ( player = PlayerId . ONE , unit_const = UnitInfo . TWO_HANDED_SWORDSMAN . ID , x = 15 , y = 15 ) unit_manager . add_unit ( player = PlayerId . ONE , unit_const = UnitInfo . CHAMPION . ID , x = 15 , y = 16 ) Take a look at the code, maybe you can see what it does? We add one unit per unit from the militia line to the editor, one per tile. Note These units are placed using whole numbers (called: integers, x=15, y=12 ), if you want units to spawn in the middle of a tile, use .5 after the integer, like so: x=15.5, y=12.5 You can also see the above code uses PlayerId and UnitInfo objects. 1 2 PlayerId.ONE # The number representing player one (1) UnitInfo.MILITIA.ID # The number representing a militia unit (74) Datasets These are datasets, A Dataset is an Enum Class that contains the constants used by the game like unit IDs, etc. These are essential to producing a scenario. Read more about them here . Let's import the datasets using the code below. Add these lines to the top of your file. 1 2 from AoE2ScenarioParser.datasets.players import PlayerId from AoE2ScenarioParser.datasets.units import UnitInfo","title":"6. Adding units"},{"location":"hello_world/#7-changing-the-map","text":"And now as final change let's add a hill and change the size of the map. First add the map_manager : 1 map_manager = scenario . map_manager Place it with the unit_manager and the trigger_manager Now let's add the code for the hill: 1 map_manager . set_elevation ( elevation = 3 , x1 = 10 , y1 = 10 , x2 = 20 , y2 = 20 ) The in-game max elevation is 7, that's equivelant to elevation=6 in the parser. This is because elevation=0 is elevation 1 in the editor. Using the parser you can go as large as you want, although above ~20 without UHD and ~15 with UHD the camera starts clipping into the hill. And finally let's shrink the map size to 40x40 tiles 1 map_manager . map_size = 40 Max map size limit The limit of a scenario is set to the size of a ludikrous map ( 480x480 ). Going over this limit will cause the game to crash. Now let's add the writing to file back: 1 scenario . write_to_file ( input_folder + \"hello world output.aoe2scenario\" ) Run the python code by pressing Shift + F10 again and check out the scenario!","title":"7. Changing the map"},{"location":"hello_world/#complete-code-block","text":"Your code should look something like the below block. You can find more examples & explanation on the cheatsheets and the examples page. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from AoE2ScenarioParser.datasets.players import PlayerId from AoE2ScenarioParser.datasets.units import UnitInfo from AoE2ScenarioParser.scenarios.aoe2_de_scenario import AoE2DEScenario # The path to your scenario folder input_folder = \"C:/path/to/your/scenario/folder/\" # The scenario object. scenario = AoE2DEScenario . from_file ( input_folder + \"hello world.aoe2scenario\" ) # Save reference to the manager, so you don't have to do \"scenario.trigger_manager...\" each time trigger_manager = scenario . trigger_manager unit_manager = scenario . unit_manager map_manager = scenario . map_manager # Save the created trigger hello_world_trigger = trigger_manager . add_trigger ( \"Hello World Trigger\" ) # Add display_instructions effect to the new trigger hello_world_trigger . new_effect . display_instructions ( display_time = 11 , message = \"Hello World\" ) unit_manager . add_unit ( player = PlayerId . ONE , unit_const = UnitInfo . MILITIA . ID , x = 15 , y = 12 ) unit_manager . add_unit ( player = PlayerId . ONE , unit_const = UnitInfo . MAN_AT_ARMS . ID , x = 15 , y = 13 ) unit_manager . add_unit ( player = PlayerId . ONE , unit_const = UnitInfo . LONG_SWORDSMAN . ID , x = 15 , y = 14 ) unit_manager . add_unit ( player = PlayerId . ONE , unit_const = UnitInfo . TWO_HANDED_SWORDSMAN . ID , x = 15 , y = 15 ) unit_manager . add_unit ( player = PlayerId . ONE , unit_const = UnitInfo . CHAMPION . ID , x = 15 , y = 16 ) map_manager . set_elevation ( elevation = 3 , x1 = 10 , y1 = 10 , x2 = 20 , y2 = 20 ) map_manager . map_size = 40 scenario . write_to_file ( input_folder + \"hello world output.aoe2scenario\" )","title":"Complete code block"},{"location":"installation/","text":"Installation \u00b6 You can install the project using pip : 1 pip install AoE2ScenarioParser Or install it manually by cloning the git repo. Note This method requires you to install the dependencies and all updates manually too. 1 git clone https://github.com/KSneijders/AoE2ScenarioParser.git Dependencies \u00b6 This project is made in Python 3. You'll need Python 3.8 or newer to be able to run it properly. The project uses deprecation for deprecation warnings. Note All these dependencies should install automatically when using the above pip command. Updating \u00b6 To update the library using pip when you have an older version, use the following command: 1 pip install --no-cache-dir --upgrade AoE2ScenarioParser To view the changes between versions, visit the GitHub page and check the changelog.md file.","title":"Installation"},{"location":"installation/#installation","text":"You can install the project using pip : 1 pip install AoE2ScenarioParser Or install it manually by cloning the git repo. Note This method requires you to install the dependencies and all updates manually too. 1 git clone https://github.com/KSneijders/AoE2ScenarioParser.git","title":"Installation"},{"location":"installation/#dependencies","text":"This project is made in Python 3. You'll need Python 3.8 or newer to be able to run it properly. The project uses deprecation for deprecation warnings. Note All these dependencies should install automatically when using the above pip command.","title":"Dependencies"},{"location":"installation/#updating","text":"To update the library using pip when you have an older version, use the following command: 1 pip install --no-cache-dir --upgrade AoE2ScenarioParser To view the changes between versions, visit the GitHub page and check the changelog.md file.","title":"Updating"},{"location":"support/","text":"Support \u00b6 If you find a bug please report it as a GitHub issue on the github issue board . If you have any questions regarding the parser, join the discord !","title":"Support"},{"location":"support/#support","text":"If you find a bug please report it as a GitHub issue on the github issue board . If you have any questions regarding the parser, join the discord !","title":"Support"},{"location":"cheatsheets/area/","text":"Area \u00b6 The Area object is a powerful object to get access to specific regions on the map. This page will try to explain a bit on how to use it and what the possibilities are. First of all, the Area object uses \"Method Chaining\". This means that methods inside the Area object return the Area object itself. This allows you to call another method straight after the first: 1 2 3 4 5 obj . x () obj . y () obj . z () # With method chaining you can do: obj . x () . y () . z () This is perfect for a highly configurable and flexible objects like the Area object. Why would I use the Area object? \u00b6 If you want to do anything with more than a single coordinate, it's quite the hassle sometimes. That's the problem this object is trying (feature suggestions always welcome!) to solve. Note The Area object strength comes from selecting specific pattern/tiles. If you want to do a similar thing with every tile on the map this object won't help you much. Examples \u00b6 Below are a couple examples that show why this object can be very useful when working with coordinates. Creating a stack of units \u00b6 Let's say you want to place 16 units, in a 4x4 area on the map. This is not necessarily difficult to do, it'd probably look something like the following: 1 2 3 4 5 6 7 8 for x in range ( 10 , 14 ): for y in range ( 50 , 54 ): unit_manager . add_unit ( player = PlayerId . ONE , unit_const = UnitInfo . KNIGHT . ID , x = x + .5 , y = y + .5 ) This would create 16 units in a 4x4 area and isn't too bad to read or write. Though, having an object which manages the area would be a lot cleaner than looping through coordinates. So, let's see how we'd do it with the Area object. 1 2 3 4 5 6 7 8 9 10 11 area = scenario . new . area () # Create a new area object # Select the area and convert it to a set of all coordinates inside of it for tile in area . select ( 10 , 50 , 13 , 53 ) . to_coords (): # Every tile is a NamedTuple with an 'x' and 'y' value unit_manager . add_unit ( player = PlayerId . ONE , unit_const = UnitInfo . KNIGHT . ID , x = tile . x + .5 , y = tile . y + .5 ) Above we can see the creation of a new Area object through the new Object Factory inside a scenario. We use the select method to select our area. Note Keep in mind that Area.select uses an inclusive selection. This means that doing: area.select(1, 1, 3, 3) will select a 3x3 area. Castle surrounded by walls \u00b6 Now, the above example was quite a simple one. The real power comes with the configuration! So let's take a more complicated example! Like creating a wall around a castle! This will be quite the difference, so let's do it in steps, first we create the castle and the area object. 1 2 castle = unit_manager . add_unit ( player = PlayerId . ONE , unit_const = BuildingInfo . CASTLE . ID , x = 30 , y = 30 ) area = scenario . new . area () Now let's select the area of the castle itself, so the 4x4 area. 1 2 3 area . center ( castle . x , castle . y ) . size ( 4 ) # Or using separate width and height calls: area . center ( castle . x , castle . y ) . width ( 4 ) . height ( 4 ) This sets the center of the area to the castles coordinates. After that we change the size of the selection from the default (1x1) to (4x4). We now have the castle area selected. Let's say we want the wall 6 tiles around the castle. Let's expand our selection by 6 tiles. 1 2 3 4 # On it's own line area . expand ( 6 ) # Or add it to the above line area . center ( castle_object . x , castle_object . y ) . size ( 4 ) . expand ( 6 ) Now we have a 16 by 16 tile area selected. The 4x4 from the castle plus the 6 tiles we expanded to all four sides. We could do the same thing as above with the knights in the 4x4 but there's a problem. The selection covers all those 256 (16*16) tiles. So we'd be filling everything with walls. We just want the edges so, let's do that. For that we use a so called \"use\" function. 1 2 3 4 # On it's own line area . use_only_edge () # Or, again, add it to the above line area . center ( castle_object . x , castle_object . y ) . size ( 4 ) . expand ( 6 ) . use_only_edge () This tells the area object we only want the outer edge of the selection. Now let's convert that to coordinates and place those walls! We can use area.to_coords() again! 1 2 3 4 5 6 7 castle = unit_manager . add_unit ( player = PlayerId . ONE , unit_const = BuildingInfo . CASTLE . ID , x = 30 , y = 30 ) area = scenario . new . area () for tile in area . center ( castle . x , castle . y ) . size ( 4 ) . expand ( 6 ) . use_only_edge () . to_coords (): unit_manager . add_unit ( player = PlayerId . ONE , unit_const = BuildingInfo . STONE_WALL . ID , x = tile . x , y = tile . y ) And that's it! The castle has walls around it. With such ease! Checkers pattern \u00b6 So, let's say we want to create a checkers pattern. Where we create squares of ice and black terrain alternately. To do this we basically need all tiles on the map but in separate squares. So selecting the entire map alone isn't enough here as we want them all separated. So, what we want is blocks of 3x3 over the course of the map. The map we're reading is a tiny 2 player map which has a size of 120 by 120 tiles. What we'll do is select the entire map and use the grid pattern. Then we use a block size of 3 and a gap size of 0. This way we get 3x3 areas. Though, we cannot use the area.to_coords() function we used before. The reason for that is because the function returns all tiles in the selection. And because we use all tiles in the map, this function will just return a large list of all tiles. What we need for this is: area.to_chunks() . Let's get started and see how it works! Alright, first, let's create the main Area object and select the entire map. 1 2 area = scenario . new . area () area . select_entire_map () After that, let's set it so that it uses the grid pattern. You can do this in two ways: 1 2 3 4 5 6 7 8 # Append to the same line area = scenario . new . area () area . select_entire_map () . use_pattern_grid () # Or add it after the last line area = scenario . new . area () area . select_entire_map () area . use_pattern_grid () Now this would be default return a grid with gaps of 1 and blocks of 1x1. We want blocks of 3x3 and no gaps (gap of 0). Below you can see the steps and the difference these configurations have: Now that we know what we want, we can add some configuration to the function, we can do this in four ways, choose the one you like the most (We'll continue with the first option): 1 2 3 4 5 6 7 8 9 10 11 12 13 # For the third option: from AoE2ScenarioParser.objects.support.area import AreaAttr ... area . use_pattern_grid ( block_size = 3 , gap_size = 0 ) ... area . use_pattern_grid () . attr ( 'block_size' , 3 ) area . use_pattern_grid () . attr ( 'gap_size' , 0 ) ... area . use_pattern_grid () . attr ( AreaAttr . BLOCK_SIZE , 3 ) area . use_pattern_grid () . attr ( AreaAttr . GAP_SIZE , 0 ) ... area . use_pattern_grid () . attrs ( block_size = 3 , gap_size = 0 ) You can differentiate the X and Y In many functions you can use the general option like gap_size . But there's also options for gap_size_x and gap_size_y if you want different selections. Now that we have the grid, let's add the final piece where we change the terrain itself. We can use the function to_chunks() to return our grid as 'chunks'. Chunks will be returned in a list and every chunk will be returned as an OrderedSet . These OrderedSet s will contain Tile objects by default. These objects just contain their x and y values. We can change this behaviour with the as_terrain parameter. Setting this to True will return the OrderedSet s with TerrainTile objects. These objects allow you to directly change the terrain on this tile. These are also the same objects returned by the Map Manager. 1 2 3 for index , chunk in enumerate ( area . to_chunks ( as_terrain = True )): for terrain_tile in chunk : terrain_tile . terrain_id = TerrainId . BLACK if index % 2 == 0 else TerrainId . ICE So the code above loops through all the 3x3 squares returned by the to_chunks function. Then for each square it loops through all the terrain tiles in the OrderedSet . We then set the terrain to BLACK or ICE depending on the index reduced by modulo 2. This will alternate the tiles between the two terrain types. There's one small adjustment we need to make. Because the map 120 tiles and the squares have a length of 3 we can fit 40 squares per row. This is an even number. So just alternating BLACK and ICE terrain based on index will cause it to create lines instead of alternating each row. We can fix this by adding the row with the index and reduce that by modulo 2 to get our ideal situation. 1 2 3 4 for index , chunk in enumerate ( area . to_chunks ( as_terrain = True )): for terrain_tile in chunk : row = index // ( map_manager . map_size / 3 ) # 3 as the size of the grid blocks terrain_tile . terrain_id = TerrainId . BLACK if ( index + row ) % 2 == 0 else TerrainId . ICE Another way to get around this is make sure the squares fit an odd amount of times in the length of the map. So using the earlier loop, without the row, with a map size of 117 (39 times) would result in the same pattern as the code above. The entire code block for this example: 1 2 3 4 5 6 7 area = scenario . new . area () area . select_entire_map () . use_pattern_grid ( block_size = 3 , gap_size = 0 ) for index , chunk in enumerate ( area . to_chunks ( as_terrain = True )): for terrain_tile in chunk : row = index // ( map_manager . map_size / 3 ) # 3 as the size of the grid blocks terrain_tile . terrain_id = TerrainId . BLACK if ( index + row ) % 2 == 0 else TerrainId . ICE API \u00b6 Functions \u00b6 In this section the functions are shown. This will eventually be replaced by a proper API doc for everything. But until then, this will have to do. Enjoy! Functions to convert to other datatype: \u00b6 .to_coords(as_terrain) Converts the selection to an OrderedSet of (x, y) coordinates Parameter Type Default Description as_terrain bool False If the returning coordinates should be Tile objects or Terrain Tiles. If True the coordinatesare returned as TerrainTiles. Returns: OrderedSet[Tile | 'TerrainTile'] .to_chunks(as_terrain, separate_by_id) Converts the selection to a list of OrderedSets with Tile NamedTuples with (x, y) coordinates. The separation between chunks is based on if they're connected to each other. So the tiles must share an edge (i.e. they should be non-diagonal). Parameter Type Default Description as_terrain bool False If the returning coordinates should be Tile objects or Terrain Tiles. If True the coordinatesare returned as TerrainTiles. separate_by_id bool True Take chunk ids into account when separating chunks. When this is true, separate 'chunks'will not be combined into one when they touch each other. For example, with a line pattern andgap_size=0 when this is False, this will result in one 'chunk' as the lines touch each other. Returns: List[OrderedSet[Tile | 'TerrainTile']] .to_dict(prefix) Converts the 2 corners of the selection to area keys for use in effects etc. This can be used by adding double stars (**) before this function. Parameter Type Default Description prefix str \"area_\" The prefix of the string before 'x1' (e.g. prefix=\"coord_\" will result in: \"coord_x1\" as key) Returns: Dict[str, int] Functions to get information from the Area object: \u00b6 .get_selection() Get the four values of the selection as: ((x1, y1), (x2, y2)) Returns: Tuple[Tuple[int, int], Tuple[int, int]] .get_center() Get center of current selection Returns: Tuple[float, float] .get_center_int() Get center of current selection, coords can only be integers. If even length, the value is ceiled Returns: Tuple[int, int] .get_range_x() Returns a range object for the x coordinates. Returns: range .get_range_y() Returns a range object for the y coordinates. Returns: range .get_width() Returns the length of the x side of the selection. Returns: int .get_height() Returns the length of the y side of the selection. Returns: int Functions to set what pattern/selection format to use: \u00b6 .use_full() Sets the area object to use the entire selection Returns: Area .use_only_edge(line_width, line_width_x, line_width_y) Sets the area object to only use the edge of the selection Parameter Type Default Description line_width int None The width of the x & y edge line line_width_x int None The width of the x edge line line_width_y int None The width of the y edge line Returns: Area .use_only_corners(corner_size, corner_size_x, corner_size_y) Sets the area object to only use the corners pattern within the selection. Parameter Type Default Description corner_size int None The size along both the x and y axis of the corner areas corner_size_x int None The size along the x axis of the corner areas corner_size_y int None The size along the y axis of the corner areas Returns: Area .use_pattern_grid(block_size, gap_size, block_size_x, block_size_y, gap_size_x, gap_size_y) Sets the area object to use a grid pattern within the selection. Parameter Type Default Description block_size int None The size of the gaps between lines gap_size int None The width of the grid lines block_size_x int None The size of the x gaps between lines block_size_y int None The size of the y gaps between lines gap_size_x int None The width of the x grid lines gap_size_y int None The width of the y grid lines Returns: Area .use_pattern_lines(axis, gap_size, line_width) Sets the area object to use a lines pattern within the selection. Parameter Type Default Description axis str None The axis the lines should follow. Can either be \"x\" or \"y\" gap_size int None The size of the gaps between lines line_width int None The width of the x & y lines Returns: Area Functions to change the selection in one way or another: \u00b6 .invert() Inverts the inverted boolean. Causes the to_coords to return the inverted selection. (Especially useful for the grid state. Not as useful for the edge which would be the same as shrinking the selection. When used with the fill state an empty set is returned. Returns: Area .along_axis(axis) Sets the axis. Can be either \"x\" or \"y\". Parameter Type Default Description axis str - - Returns: Area .attr(key, value) Sets the attribute to the given value. AreaAttr or str can be used as key Parameter Type Default Description key str | AreaAttr - - value int - - Returns: Area .attrs(x1, y1, x2, y2, gap_size, gap_size_x, gap_size_y, line_width, line_width_x, line_width_y, axis, corner_size, corner_size_x, corner_size_y, block_size, block_size_x, block_size_y) Sets multiple attributes to the corresponding values. Parameter Type Default Description x1 int None - y1 int None - x2 int None - y2 int None - gap_size int None - gap_size_x int None - gap_size_y int None - line_width int None - line_width_x int None - line_width_y int None - axis str None - corner_size int None - corner_size_x int None - corner_size_y int None - block_size int None - block_size_x int None - block_size_y int None - Returns: Area .size(n) Sets the selection to a size around the center. If center is (4,4) with a size of 3 the selection will become ((3,3), (5,5)) Parameter Type Default Description n int - - Returns: Area .height(n) Sets the height (y axis) of the selection. Shrinks/Expands both sides equally. If the expansion hits the edge of the map, it'll expand on the other side. Parameter Type Default Description n int - - Returns: Area .width(n) Sets the width (x axis) of the selection. Shrinks/Expands both sides equally. If the expansion hits the edge of the map, it'll expand on the other side. Parameter Type Default Description n int - - Returns: Area .center(x, y) Moves the selection center to a given position. When the given center forces the selection of the edge of the map, the selection is moved to that position and all tiles that are out of the map are removed from the selection, effectively decreasing the selection size. Parameter Type Default Description x int - - y int - - Returns: Area .center_bounded(x, y) Moves the selection center to a given position on the map. This function makes sure it cannot go over the edge of the map. The selection will be forced against the edge of the map but the selection will not be decreased. Parameter Type Default Description x int - - y int - - Returns: Area .select_entire_map() Sets the selection to the entire map Returns: Area .select(x1, y1, x2, y2) Sets the selection to the given coordinates Parameter Type Default Description x1 int - - y1 int - - x2 int None - y2 int None - Returns: Area .select_centered(x, y, dx, dy) Sets the selection to the given coordinates Parameter Type Default Description x int - - y int - - dx int 1 - dy int 1 - Returns: Area .shrink(n) Shrinks the selection from all sides Parameter Type Default Description n int - - Returns: Area .shrink_x1(n) Shrinks the selection from the first corner on the X axis by n Parameter Type Default Description n int - - Returns: Area .shrink_y1(n) Shrinks the selection from the first corner on the Y axis by n Parameter Type Default Description n int - - Returns: Area .shrink_x2(n) Shrinks the selection from the second corner on the X axis by n Parameter Type Default Description n int - - Returns: Area .shrink_y2(n) Shrinks the selection from the second corner on the Y axis by n Parameter Type Default Description n int - - Returns: Area .expand(n) Expands the selection from all sides Parameter Type Default Description n int - - Returns: Area .expand_x1(n) Expands the selection from the first corner on the X axis by n Parameter Type Default Description n int - - Returns: Area .expand_y1(n) Expands the selection from the first corner on the Y axis by n Parameter Type Default Description n int - - Returns: Area .expand_x2(n) Expands the selection from the second corner on the X axis by n Parameter Type Default Description n int - - Returns: Area .expand_y2(n) Expands the selection from the second corner on the Y axis by n Parameter Type Default Description n int - - Returns: Area Other relevant functions: \u00b6 .is_within_selection(x, y, tile) If a given (x,y) location is within the selection. Parameter Type Default Description x int -1 The X coordinate y int -1 The Y coordinate tile Tile None A Tile object, replacing the x & y coordinates Returns: bool .associate_scenario(scenario) Associate area with scenario. Saves scenario UUID in this area object. Parameter Type Default Description scenario AoE2Scenario - The scenario to associate with Returns: None .copy() Copy this instance of an Area. Useful for when you want to do multiple extractions (to_...) from the same source with small tweaks. Returns: Area","title":"Area"},{"location":"cheatsheets/area/#area","text":"The Area object is a powerful object to get access to specific regions on the map. This page will try to explain a bit on how to use it and what the possibilities are. First of all, the Area object uses \"Method Chaining\". This means that methods inside the Area object return the Area object itself. This allows you to call another method straight after the first: 1 2 3 4 5 obj . x () obj . y () obj . z () # With method chaining you can do: obj . x () . y () . z () This is perfect for a highly configurable and flexible objects like the Area object.","title":"Area"},{"location":"cheatsheets/area/#why-would-i-use-the-area-object","text":"If you want to do anything with more than a single coordinate, it's quite the hassle sometimes. That's the problem this object is trying (feature suggestions always welcome!) to solve. Note The Area object strength comes from selecting specific pattern/tiles. If you want to do a similar thing with every tile on the map this object won't help you much.","title":"Why would I use the Area object?"},{"location":"cheatsheets/area/#examples","text":"Below are a couple examples that show why this object can be very useful when working with coordinates.","title":"Examples"},{"location":"cheatsheets/area/#creating-a-stack-of-units","text":"Let's say you want to place 16 units, in a 4x4 area on the map. This is not necessarily difficult to do, it'd probably look something like the following: 1 2 3 4 5 6 7 8 for x in range ( 10 , 14 ): for y in range ( 50 , 54 ): unit_manager . add_unit ( player = PlayerId . ONE , unit_const = UnitInfo . KNIGHT . ID , x = x + .5 , y = y + .5 ) This would create 16 units in a 4x4 area and isn't too bad to read or write. Though, having an object which manages the area would be a lot cleaner than looping through coordinates. So, let's see how we'd do it with the Area object. 1 2 3 4 5 6 7 8 9 10 11 area = scenario . new . area () # Create a new area object # Select the area and convert it to a set of all coordinates inside of it for tile in area . select ( 10 , 50 , 13 , 53 ) . to_coords (): # Every tile is a NamedTuple with an 'x' and 'y' value unit_manager . add_unit ( player = PlayerId . ONE , unit_const = UnitInfo . KNIGHT . ID , x = tile . x + .5 , y = tile . y + .5 ) Above we can see the creation of a new Area object through the new Object Factory inside a scenario. We use the select method to select our area. Note Keep in mind that Area.select uses an inclusive selection. This means that doing: area.select(1, 1, 3, 3) will select a 3x3 area.","title":"Creating a stack of units"},{"location":"cheatsheets/area/#castle-surrounded-by-walls","text":"Now, the above example was quite a simple one. The real power comes with the configuration! So let's take a more complicated example! Like creating a wall around a castle! This will be quite the difference, so let's do it in steps, first we create the castle and the area object. 1 2 castle = unit_manager . add_unit ( player = PlayerId . ONE , unit_const = BuildingInfo . CASTLE . ID , x = 30 , y = 30 ) area = scenario . new . area () Now let's select the area of the castle itself, so the 4x4 area. 1 2 3 area . center ( castle . x , castle . y ) . size ( 4 ) # Or using separate width and height calls: area . center ( castle . x , castle . y ) . width ( 4 ) . height ( 4 ) This sets the center of the area to the castles coordinates. After that we change the size of the selection from the default (1x1) to (4x4). We now have the castle area selected. Let's say we want the wall 6 tiles around the castle. Let's expand our selection by 6 tiles. 1 2 3 4 # On it's own line area . expand ( 6 ) # Or add it to the above line area . center ( castle_object . x , castle_object . y ) . size ( 4 ) . expand ( 6 ) Now we have a 16 by 16 tile area selected. The 4x4 from the castle plus the 6 tiles we expanded to all four sides. We could do the same thing as above with the knights in the 4x4 but there's a problem. The selection covers all those 256 (16*16) tiles. So we'd be filling everything with walls. We just want the edges so, let's do that. For that we use a so called \"use\" function. 1 2 3 4 # On it's own line area . use_only_edge () # Or, again, add it to the above line area . center ( castle_object . x , castle_object . y ) . size ( 4 ) . expand ( 6 ) . use_only_edge () This tells the area object we only want the outer edge of the selection. Now let's convert that to coordinates and place those walls! We can use area.to_coords() again! 1 2 3 4 5 6 7 castle = unit_manager . add_unit ( player = PlayerId . ONE , unit_const = BuildingInfo . CASTLE . ID , x = 30 , y = 30 ) area = scenario . new . area () for tile in area . center ( castle . x , castle . y ) . size ( 4 ) . expand ( 6 ) . use_only_edge () . to_coords (): unit_manager . add_unit ( player = PlayerId . ONE , unit_const = BuildingInfo . STONE_WALL . ID , x = tile . x , y = tile . y ) And that's it! The castle has walls around it. With such ease!","title":"Castle surrounded by walls"},{"location":"cheatsheets/area/#checkers-pattern","text":"So, let's say we want to create a checkers pattern. Where we create squares of ice and black terrain alternately. To do this we basically need all tiles on the map but in separate squares. So selecting the entire map alone isn't enough here as we want them all separated. So, what we want is blocks of 3x3 over the course of the map. The map we're reading is a tiny 2 player map which has a size of 120 by 120 tiles. What we'll do is select the entire map and use the grid pattern. Then we use a block size of 3 and a gap size of 0. This way we get 3x3 areas. Though, we cannot use the area.to_coords() function we used before. The reason for that is because the function returns all tiles in the selection. And because we use all tiles in the map, this function will just return a large list of all tiles. What we need for this is: area.to_chunks() . Let's get started and see how it works! Alright, first, let's create the main Area object and select the entire map. 1 2 area = scenario . new . area () area . select_entire_map () After that, let's set it so that it uses the grid pattern. You can do this in two ways: 1 2 3 4 5 6 7 8 # Append to the same line area = scenario . new . area () area . select_entire_map () . use_pattern_grid () # Or add it after the last line area = scenario . new . area () area . select_entire_map () area . use_pattern_grid () Now this would be default return a grid with gaps of 1 and blocks of 1x1. We want blocks of 3x3 and no gaps (gap of 0). Below you can see the steps and the difference these configurations have: Now that we know what we want, we can add some configuration to the function, we can do this in four ways, choose the one you like the most (We'll continue with the first option): 1 2 3 4 5 6 7 8 9 10 11 12 13 # For the third option: from AoE2ScenarioParser.objects.support.area import AreaAttr ... area . use_pattern_grid ( block_size = 3 , gap_size = 0 ) ... area . use_pattern_grid () . attr ( 'block_size' , 3 ) area . use_pattern_grid () . attr ( 'gap_size' , 0 ) ... area . use_pattern_grid () . attr ( AreaAttr . BLOCK_SIZE , 3 ) area . use_pattern_grid () . attr ( AreaAttr . GAP_SIZE , 0 ) ... area . use_pattern_grid () . attrs ( block_size = 3 , gap_size = 0 ) You can differentiate the X and Y In many functions you can use the general option like gap_size . But there's also options for gap_size_x and gap_size_y if you want different selections. Now that we have the grid, let's add the final piece where we change the terrain itself. We can use the function to_chunks() to return our grid as 'chunks'. Chunks will be returned in a list and every chunk will be returned as an OrderedSet . These OrderedSet s will contain Tile objects by default. These objects just contain their x and y values. We can change this behaviour with the as_terrain parameter. Setting this to True will return the OrderedSet s with TerrainTile objects. These objects allow you to directly change the terrain on this tile. These are also the same objects returned by the Map Manager. 1 2 3 for index , chunk in enumerate ( area . to_chunks ( as_terrain = True )): for terrain_tile in chunk : terrain_tile . terrain_id = TerrainId . BLACK if index % 2 == 0 else TerrainId . ICE So the code above loops through all the 3x3 squares returned by the to_chunks function. Then for each square it loops through all the terrain tiles in the OrderedSet . We then set the terrain to BLACK or ICE depending on the index reduced by modulo 2. This will alternate the tiles between the two terrain types. There's one small adjustment we need to make. Because the map 120 tiles and the squares have a length of 3 we can fit 40 squares per row. This is an even number. So just alternating BLACK and ICE terrain based on index will cause it to create lines instead of alternating each row. We can fix this by adding the row with the index and reduce that by modulo 2 to get our ideal situation. 1 2 3 4 for index , chunk in enumerate ( area . to_chunks ( as_terrain = True )): for terrain_tile in chunk : row = index // ( map_manager . map_size / 3 ) # 3 as the size of the grid blocks terrain_tile . terrain_id = TerrainId . BLACK if ( index + row ) % 2 == 0 else TerrainId . ICE Another way to get around this is make sure the squares fit an odd amount of times in the length of the map. So using the earlier loop, without the row, with a map size of 117 (39 times) would result in the same pattern as the code above. The entire code block for this example: 1 2 3 4 5 6 7 area = scenario . new . area () area . select_entire_map () . use_pattern_grid ( block_size = 3 , gap_size = 0 ) for index , chunk in enumerate ( area . to_chunks ( as_terrain = True )): for terrain_tile in chunk : row = index // ( map_manager . map_size / 3 ) # 3 as the size of the grid blocks terrain_tile . terrain_id = TerrainId . BLACK if ( index + row ) % 2 == 0 else TerrainId . ICE","title":"Checkers pattern"},{"location":"cheatsheets/area/#api","text":"","title":"API"},{"location":"cheatsheets/area/#functions","text":"In this section the functions are shown. This will eventually be replaced by a proper API doc for everything. But until then, this will have to do. Enjoy!","title":"Functions"},{"location":"cheatsheets/area/#functions-to-convert-to-other-datatype","text":".to_coords(as_terrain) Converts the selection to an OrderedSet of (x, y) coordinates Parameter Type Default Description as_terrain bool False If the returning coordinates should be Tile objects or Terrain Tiles. If True the coordinatesare returned as TerrainTiles. Returns: OrderedSet[Tile | 'TerrainTile'] .to_chunks(as_terrain, separate_by_id) Converts the selection to a list of OrderedSets with Tile NamedTuples with (x, y) coordinates. The separation between chunks is based on if they're connected to each other. So the tiles must share an edge (i.e. they should be non-diagonal). Parameter Type Default Description as_terrain bool False If the returning coordinates should be Tile objects or Terrain Tiles. If True the coordinatesare returned as TerrainTiles. separate_by_id bool True Take chunk ids into account when separating chunks. When this is true, separate 'chunks'will not be combined into one when they touch each other. For example, with a line pattern andgap_size=0 when this is False, this will result in one 'chunk' as the lines touch each other. Returns: List[OrderedSet[Tile | 'TerrainTile']] .to_dict(prefix) Converts the 2 corners of the selection to area keys for use in effects etc. This can be used by adding double stars (**) before this function. Parameter Type Default Description prefix str \"area_\" The prefix of the string before 'x1' (e.g. prefix=\"coord_\" will result in: \"coord_x1\" as key) Returns: Dict[str, int]","title":"Functions to convert to other datatype:"},{"location":"cheatsheets/area/#functions-to-get-information-from-the-area-object","text":".get_selection() Get the four values of the selection as: ((x1, y1), (x2, y2)) Returns: Tuple[Tuple[int, int], Tuple[int, int]] .get_center() Get center of current selection Returns: Tuple[float, float] .get_center_int() Get center of current selection, coords can only be integers. If even length, the value is ceiled Returns: Tuple[int, int] .get_range_x() Returns a range object for the x coordinates. Returns: range .get_range_y() Returns a range object for the y coordinates. Returns: range .get_width() Returns the length of the x side of the selection. Returns: int .get_height() Returns the length of the y side of the selection. Returns: int","title":"Functions to get information from the Area object:"},{"location":"cheatsheets/area/#functions-to-set-what-patternselection-format-to-use","text":".use_full() Sets the area object to use the entire selection Returns: Area .use_only_edge(line_width, line_width_x, line_width_y) Sets the area object to only use the edge of the selection Parameter Type Default Description line_width int None The width of the x & y edge line line_width_x int None The width of the x edge line line_width_y int None The width of the y edge line Returns: Area .use_only_corners(corner_size, corner_size_x, corner_size_y) Sets the area object to only use the corners pattern within the selection. Parameter Type Default Description corner_size int None The size along both the x and y axis of the corner areas corner_size_x int None The size along the x axis of the corner areas corner_size_y int None The size along the y axis of the corner areas Returns: Area .use_pattern_grid(block_size, gap_size, block_size_x, block_size_y, gap_size_x, gap_size_y) Sets the area object to use a grid pattern within the selection. Parameter Type Default Description block_size int None The size of the gaps between lines gap_size int None The width of the grid lines block_size_x int None The size of the x gaps between lines block_size_y int None The size of the y gaps between lines gap_size_x int None The width of the x grid lines gap_size_y int None The width of the y grid lines Returns: Area .use_pattern_lines(axis, gap_size, line_width) Sets the area object to use a lines pattern within the selection. Parameter Type Default Description axis str None The axis the lines should follow. Can either be \"x\" or \"y\" gap_size int None The size of the gaps between lines line_width int None The width of the x & y lines Returns: Area","title":"Functions to set what pattern/selection format to use:"},{"location":"cheatsheets/area/#functions-to-change-the-selection-in-one-way-or-another","text":".invert() Inverts the inverted boolean. Causes the to_coords to return the inverted selection. (Especially useful for the grid state. Not as useful for the edge which would be the same as shrinking the selection. When used with the fill state an empty set is returned. Returns: Area .along_axis(axis) Sets the axis. Can be either \"x\" or \"y\". Parameter Type Default Description axis str - - Returns: Area .attr(key, value) Sets the attribute to the given value. AreaAttr or str can be used as key Parameter Type Default Description key str | AreaAttr - - value int - - Returns: Area .attrs(x1, y1, x2, y2, gap_size, gap_size_x, gap_size_y, line_width, line_width_x, line_width_y, axis, corner_size, corner_size_x, corner_size_y, block_size, block_size_x, block_size_y) Sets multiple attributes to the corresponding values. Parameter Type Default Description x1 int None - y1 int None - x2 int None - y2 int None - gap_size int None - gap_size_x int None - gap_size_y int None - line_width int None - line_width_x int None - line_width_y int None - axis str None - corner_size int None - corner_size_x int None - corner_size_y int None - block_size int None - block_size_x int None - block_size_y int None - Returns: Area .size(n) Sets the selection to a size around the center. If center is (4,4) with a size of 3 the selection will become ((3,3), (5,5)) Parameter Type Default Description n int - - Returns: Area .height(n) Sets the height (y axis) of the selection. Shrinks/Expands both sides equally. If the expansion hits the edge of the map, it'll expand on the other side. Parameter Type Default Description n int - - Returns: Area .width(n) Sets the width (x axis) of the selection. Shrinks/Expands both sides equally. If the expansion hits the edge of the map, it'll expand on the other side. Parameter Type Default Description n int - - Returns: Area .center(x, y) Moves the selection center to a given position. When the given center forces the selection of the edge of the map, the selection is moved to that position and all tiles that are out of the map are removed from the selection, effectively decreasing the selection size. Parameter Type Default Description x int - - y int - - Returns: Area .center_bounded(x, y) Moves the selection center to a given position on the map. This function makes sure it cannot go over the edge of the map. The selection will be forced against the edge of the map but the selection will not be decreased. Parameter Type Default Description x int - - y int - - Returns: Area .select_entire_map() Sets the selection to the entire map Returns: Area .select(x1, y1, x2, y2) Sets the selection to the given coordinates Parameter Type Default Description x1 int - - y1 int - - x2 int None - y2 int None - Returns: Area .select_centered(x, y, dx, dy) Sets the selection to the given coordinates Parameter Type Default Description x int - - y int - - dx int 1 - dy int 1 - Returns: Area .shrink(n) Shrinks the selection from all sides Parameter Type Default Description n int - - Returns: Area .shrink_x1(n) Shrinks the selection from the first corner on the X axis by n Parameter Type Default Description n int - - Returns: Area .shrink_y1(n) Shrinks the selection from the first corner on the Y axis by n Parameter Type Default Description n int - - Returns: Area .shrink_x2(n) Shrinks the selection from the second corner on the X axis by n Parameter Type Default Description n int - - Returns: Area .shrink_y2(n) Shrinks the selection from the second corner on the Y axis by n Parameter Type Default Description n int - - Returns: Area .expand(n) Expands the selection from all sides Parameter Type Default Description n int - - Returns: Area .expand_x1(n) Expands the selection from the first corner on the X axis by n Parameter Type Default Description n int - - Returns: Area .expand_y1(n) Expands the selection from the first corner on the Y axis by n Parameter Type Default Description n int - - Returns: Area .expand_x2(n) Expands the selection from the second corner on the X axis by n Parameter Type Default Description n int - - Returns: Area .expand_y2(n) Expands the selection from the second corner on the Y axis by n Parameter Type Default Description n int - - Returns: Area","title":"Functions to change the selection in one way or another:"},{"location":"cheatsheets/area/#other-relevant-functions","text":".is_within_selection(x, y, tile) If a given (x,y) location is within the selection. Parameter Type Default Description x int -1 The X coordinate y int -1 The Y coordinate tile Tile None A Tile object, replacing the x & y coordinates Returns: bool .associate_scenario(scenario) Associate area with scenario. Saves scenario UUID in this area object. Parameter Type Default Description scenario AoE2Scenario - The scenario to associate with Returns: None .copy() Copy this instance of an Area. Useful for when you want to do multiple extractions (to_...) from the same source with small tweaks. Returns: Area","title":"Other relevant functions:"},{"location":"cheatsheets/datasets/","text":"Datasets \u00b6 The project currently contains multiple datasets. You can get access to the datasets by importing them. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # Information about the conditions & effects and their attributes from AoE2ScenarioParser.datasets.conditions import ConditionId from AoE2ScenarioParser.datasets.effects import EffectId from AoE2ScenarioParser.datasets.object_support import Civilization , StartingAge from AoE2ScenarioParser.datasets.trigger_lists import \\ DiplomacyState , Operation , ButtonLocation , PanelLocation , \\ TimeUnit , VisibilityState , DifficultyLevel , TechnologyState , \\ Comparison , ObjectAttribute , Attribute , UnitAIAction , \\ AttackStance , ObjectType , ObjectClass , DamageClass , \\ HeroStatusFlag , Hotkey , BlastLevel , TerrainRestrictions , \\ ColorMood , ObjectState , SecondaryGameMode # Information of unit/building/hero and tech IDs from AoE2ScenarioParser.datasets.projectiles import ProjectileInfo from AoE2ScenarioParser.datasets.buildings import BuildingInfo from AoE2ScenarioParser.datasets.heroes import HeroInfo from AoE2ScenarioParser.datasets.other import OtherInfo from AoE2ScenarioParser.datasets.techs import TechInfo from AoE2ScenarioParser.datasets.units import UnitInfo # Information about terrain IDs from AoE2ScenarioParser.datasets.terrains import TerrainId # Information about player IDs from AoE2ScenarioParser.datasets.players import PlayerId , PlayerColorId , ColorId A special thanks to Alian713 for doing A LOT of the work in contributing the data needed for these datasets. Conditions & Effects \u00b6 The condition and effect datasets aren't really necessary in regular scripting after adding the new methods for adding effects & conditions: 1 effect = trigger . new_effect . change_diplomacy ( ... ) They can still be used if you want the effect & condition IDs for other purposes. 1 2 Condition . OBJECTS_IN_AREA # 5 Effect . PATROL # 19 1 2 3 4 5 6 7 # Checking the docs for EffectId.CHANGE_DIPLOMACY will show: \"\"\" Attributes for the **change_diplomacy** effect are: - diplomacy - player_source - player_target \"\"\" Conditions & Effects lists \u00b6 Many conditions and effects have dropdown lists with options. These options are, like everything else, impossible to remember. That's why these datasets have been added: Names Explanation Example DiplomacyState Used in the Change Diplomacy effect and the Diplomacy State condition. DiplomacyState.ALLY Operation Used in many effects. Generally related to variables. Operation.MULTIPLY ButtonLocation * Used in the Change Research Location and Change Train Location effects. * ButtonLocation.r2c3 PanelLocation Used in the Display Instructions effect. PanelLocation.CENTER TimeUnit Used in the Display Timer effect. TimeUnit.YEARS VisibilityState Used in the Set Player Visibility effect. VisibilityState.EXPLORED DifficultyLevel Used in the Difficulty Level condition. DifficultyLevel.HARDEST TechnologyState Used in the Technology State condition. TechnologyState.RESEARCHING Comparison Used in many effects and conditions. Generally related to variables. Comparison.EQUAL ObjectAttribute Used in the Modify Attribute effect. ObjectAttribute.CARRY_CAPACITY Attribute Used in the Accumulate Attribute effect. Attribute.ALL_TECHS_ACHIEVED UnitAIAction Used in the Object has Action condition. UnitAIAction.ATTACK AttackStance Used in the Change Object Stance effect. AttackStance.AGGRESSIVE_STANCE ObjectType Used in every unit selection effect & condition. ObjectType.DOPPELGANGER ObjectClass Used in every unit selection effect & condition. ObjectClass.INFANTRY DamageClass Used in the Change Object Attack/Armour effects. DamageClass.SPEARMEN HeroStatusFlag * Can be used for changing the HERO_STATUS in ObjectAttribute . * HeroStatusFlag.HERO_REGENERATION Hotkey Can be used for changing the HOTKEY_ID in ObjectAttribute . Hotkey.SPACE BlastLevel Can be used for changing the BLAST_<>_LEVEL properties in ObjectAttribute . BlastLevel.NEARBY_UNITS TerrainRestrictions Can be used for changing the TERRAIN_RESTRICTION_ID in ObjectAttribute . TerrainRestrictions.LAND SmartProjectile Can be used for changing the ENABLE_SMART_PROJECTILES in ObjectAttribute . SmartProjectile.ENABLED ColorMood Used in the Change Color Mood effect. ColorMood.WINTER ObjectState Used in the Objects in area condition. ObjectState.DEAD ColorId Used in the player manager for setting the player color. ColorId.GREEN Civilization Used in the player manager for setting the player civilization. Civilization.MAYANS StartingAge Used in the player manager for setting the player starting age. StartingAge.FEUDAL_AGE SecondaryGameMode Used for setting the secondary victory conditions. SecondaryGameMode.SUDDEN_DEATH *: Means extra functionality listed below. ButtonLocation \u00b6 1 ButtonLocation . row_col ( 1 , 3 ) # ButtonLocation.r1c3 HeroStatusFlag \u00b6 1 2 3 4 5 6 # Both have the same result hsf = HeroStatusFlag . CANNOT_BE_CONVERTED + HeroStatusFlag . DELETE_CONFIRMATION hsf = HeroStatusFlag . combine ( cannot_be_converted = True , delete_confirmation = True ) General usage examples: \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 trigger = trigger_manager . add_trigger ( \"Inform Betrayal!\" ) condition = trigger . new_condition . diplomacy_state ( quantity = DiplomacyState . ALLY , # <-- DiplomacyState dataset source_player = PlayerId . TWO , target_player = PlayerId . THREE ) effect = trigger . new_effect . display_instructions ( source_player = PlayerId . ONE , message = \"Spy: Your ally has betrayed you! He allied the enemy!\" , instruction_panel_position = PanelLocation . CENTER , # <-- PanelLocation dataset display_time = 10 ) Unit, Building, Techs etc. \u00b6 The Units and Buildings datasets are very useful when adding units. They're also, together with the Tech dataset, very useful when adding or editing triggers. General Usage \u00b6 These are the biggest datasets and most powerful datasets: Dataset Description UnitInfo Dataset for units BuildingInfo Dataset for buildings HeroInfo Dataset for heroes OtherInfo Dataset for other units (like relics and gold piles) TechInfo Dataset for technologies For adding units it'll look something like the following: 1 2 3 4 5 unit_manager . add_unit ( PlayerId . ONE , UnitInfo . CONQUISTADOR . ID , x = 10 , y = 20 ) unit_manager . add_unit ( PlayerId . TWO , UnitInfo . PALADIN . ID , x = 20 , y = 20 ) unit_manager . add_unit ( PlayerId . GAIA , BuildingInfo . FEITORIA . ID , x = 30 , y = 20 ) unit_manager . add_unit ( PlayerId . GAIA , HeroInfo . WILLIAM_WALLACE . ID , x = 40 , y = 20 ) unit_manager . add_unit ( PlayerId . GAIA , OtherInfo . GOLD_MINE . ID , x = 50 , y = 20 ) With the triggers you can do similar stuff like: 1 2 3 4 5 6 7 8 9 10 ... effect = trigger . new_effect . create_object ( object_list_unit_id = OtherInfo . RELIC . ID ) ... effect = trigger . new_effect . research_technology ( source_player = PlayerId . THREE , technology = TechInfo . BLOODLINES . ID ) ... UnitInfo functions \u00b6 Some useful functions for the UnitInfo dataset is vils() and unique_units() 1 2 3 4 5 6 # Get all villager units (e.g. FARMER, HUNTER, LUMBERJACK etc.) # You can disable certain categories like: # - exclude_male # - exclude_female # Example: male_vils = UnitInfo . vils ( exclude_female = True ) 1 2 3 4 5 6 7 8 # Get all unique units (e.g. HUSKARL, CONQUISTADOR, LONGBOAT, SLINGER etc.) # You can disable certain categories like: # - exclude_elite_units # - exclude_non_elite_units # - exclude_castle_units (From the castle building) # - exclude_non_castle_units (From anything but the castle building) # Example: all_unique_non_castle_non_elite_units = UnitInfo . unique_units ( exclude_elite_units = True , exclude_castle_units = True ) TechInfo functions \u00b6 Some useful functions for the TechInfo dataset are: unique_techs() 1 2 3 4 5 6 # Get all unique techs (e.g. BEARDED_AXE, CHIEFTAINS, FIRST_CRUSADE etc.) # You can disable certain categories like: # - exclude_castle_techs # - exclude_imp_techs # Example: imp_unique_techs = TechInfo . unique_techs ( exclude_castle_techs = True ) unique_unit_upgrades() 1 2 3 4 5 6 # Get all unique unit techs (e.g. ELITE_LONGBOWMAN, ELITE_TEUTONIC_KNIGHT etc.) # You can disable certain categories like: # - exclude_castle_techs # - exclude_non_castle_techs (Excludes stuff like: ELITE_LONGBOAT, IMPERIAL_SKIRMISHER) # Example: uu_castle_upgrades = TechInfo . unique_unit_upgrades ( exclude_non_castle_techs = True ) blacksmith_techs() monastery_techs() university_techs() town_center_techs() 1 2 3 4 5 6 7 8 9 # Get all blacksmith/monastery/university techs # You can filter on ages, like so: all_blacksmith_techs = TechInfo . blacksmith_techs () feudal_blacksmith_techs = TechInfo . blacksmith_techs ( Age . FEUDAL_AGE ) non_imp_blacksmith_techs = TechInfo . blacksmith_techs ([ Age . FEUDAL_AGE , Age . CASTLE_AGE ]) # Same goes for: # - TechInfo.monastery_techs(...) # - TechInfo.university_techs(...) # - TechInfo.town_center_techs(...) eco_techs() 1 2 3 4 5 6 7 8 9 10 11 12 13 # Get all economic techs all_eco_techs = TechInfo . eco_techs () # You can filter on ages (like with blacksmith_techs etc.): dark_age_eco_techs = TechInfo . eco_techs ( ages = Age . DARK_AGE ) # Only returns LOOM # Or filter on buildings mining_and_lumber_upgrades = TechInfo . eco_techs ( buildings = [ BuildingInfo . MINING_CAMP . ID , BuildingInfo . LUMBER_CAMP . ID ] ) # Or both: imp_tc_upgrades = TechInfo . eco_techs ( ages = Age . IMPERIAL_AGE , buildings = BuildingInfo . TOWN_CENTER . ID , ) OtherInfo functions \u00b6 One useful function for the OtherInfo dataset is trees() : 1 2 3 # Get all tree objects (e.g. OAK_TREE, PINE_TREE, BAMBOO etc.) # Example: all_trees = OtherInfo . trees () Icon, Dead & Hotkey IDs \u00b6 Besides normal IDs, you might want to access their icon or dead version. Almost every unit, building, hero and tech has an icon. Most units, buildings and heroes also have a dead unit version to represent the dying animation. You can access these values using the same datasets: 1 2 3 4 5 6 7 8 9 10 11 12 13 archer_id = UnitInfo . ARCHER . ID # 4 archer_icon = UnitInfo . ARCHER . ICON_ID # 17 archer_death = UnitInfo . ARCHER . DEAD_ID # 3 archer_hotkey_id = UnitInfo . ARCHER . HOTKEY_ID # 16083 # You can also get the datasets from these values UnitInfo . from_id ( 4 ) # UnitInfo.ARCHER UnitInfo . from_icon_id ( 17 ) # UnitInfo.ARCHER UnitInfo . from_dead_id ( 3 ) # UnitInfo.ARCHER UnitInfo . from_hotkey_id ( 16083 ) # UnitInfo.ARCHER # It's also still possible to use the string like normal enums: UnitInfo [ \"ARCHER\" ] # UnitInfo.ARCHER GAIA \u00b6 If you want to know if a unit etc. is a gaia only object, you can do: 1 2 3 4 5 6 UnitInfo . ARCHER . IS_GAIA_ONLY # False UnitInfo . WOLF . IS_GAIA_ONLY # True # Or for a list: UnitInfo . gaia_only () # Returns all units which have 'IS_GAIA_ONLY' as True UnitInfo . non_gaia () # Returns all units which have 'IS_GAIA_ONLY' as False Projectiles \u00b6 If you wanted to change a projectile of archers to that of an arambai, you could do: 1 2 3 4 5 6 7 trigger . new_effect . modify_attribute ( quantity = ProjectileInfo . ARAMBAI . ID , object_list_unit_id = UnitInfo . ARCHER . ID , source_player = PlayerId . ONE , operation = Operation . SET , object_attributes = ObjectAttribute . PROJECTILE_UNIT ) Not all projectiles have the most obvious names. So you can use the following to find projectiles easier. 1 2 # Get the second projectile that a CHU KO NU shoots. (Pre-chemistry arrows) ProjectileInfo . get_unit_projectile ( UnitInfo . CHU_KO_NU . ID , has_chemistry = False , secondary = True ) Terrains \u00b6 The terrain dataset can be used for changing terrain types. 1 2 3 4 5 6 TerrainId . BEACH # 2 TerrainId . FOREST_OAK # 10 TerrainId . UNDERBUSH_LEAVES # 71 # Changing the terrain could be done like so: map_manager . terrain [ 0 ] . terrain_id = TerrainId . GRASS_1 Players \u00b6 For selecting players it can be as easy as typing 1 . Unfortunately not all parts of the scenario file are structured like: 0: Gaia, 1: Player1 ... 8: Player8 . So because of this a representation layer has been added. It's a simple Enum which looks like this: 1 2 3 PlayerId . GAIA , PlayerId . ONE , PlayerId . TWO , PlayerId . THREE , PlayerId . FOUR , PlayerId . FIVE , PlayerId . SIX , PlayerId . SEVEN , PlayerId . EIGHT If you want to loop through players, you have 2 options: 1 2 3 4 5 6 7 # Python built-in range function: for player in range ( 9 ): # Or range(1, 9) if you want to exclude GAIA # ... code... # The PlayerId function: for player in PlayerId . all (): # Or PlayerId.all(exclude_gaia=True) if you want to exclude GAIA # ... code... You can also address the players by color if you prefer it: 1 2 PlayerColorId . BLUE , PlayerColorId . RED , PlayerColorId . GREEN , PlayerColorId . YELLOW , PlayerColorId . AQUA , PlayerColorId . PURPLE , PlayerColorId . GRAY , PlayerColorId . ORANGE","title":"Datasets"},{"location":"cheatsheets/datasets/#datasets","text":"The project currently contains multiple datasets. You can get access to the datasets by importing them. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # Information about the conditions & effects and their attributes from AoE2ScenarioParser.datasets.conditions import ConditionId from AoE2ScenarioParser.datasets.effects import EffectId from AoE2ScenarioParser.datasets.object_support import Civilization , StartingAge from AoE2ScenarioParser.datasets.trigger_lists import \\ DiplomacyState , Operation , ButtonLocation , PanelLocation , \\ TimeUnit , VisibilityState , DifficultyLevel , TechnologyState , \\ Comparison , ObjectAttribute , Attribute , UnitAIAction , \\ AttackStance , ObjectType , ObjectClass , DamageClass , \\ HeroStatusFlag , Hotkey , BlastLevel , TerrainRestrictions , \\ ColorMood , ObjectState , SecondaryGameMode # Information of unit/building/hero and tech IDs from AoE2ScenarioParser.datasets.projectiles import ProjectileInfo from AoE2ScenarioParser.datasets.buildings import BuildingInfo from AoE2ScenarioParser.datasets.heroes import HeroInfo from AoE2ScenarioParser.datasets.other import OtherInfo from AoE2ScenarioParser.datasets.techs import TechInfo from AoE2ScenarioParser.datasets.units import UnitInfo # Information about terrain IDs from AoE2ScenarioParser.datasets.terrains import TerrainId # Information about player IDs from AoE2ScenarioParser.datasets.players import PlayerId , PlayerColorId , ColorId A special thanks to Alian713 for doing A LOT of the work in contributing the data needed for these datasets.","title":"Datasets"},{"location":"cheatsheets/datasets/#conditions-effects","text":"The condition and effect datasets aren't really necessary in regular scripting after adding the new methods for adding effects & conditions: 1 effect = trigger . new_effect . change_diplomacy ( ... ) They can still be used if you want the effect & condition IDs for other purposes. 1 2 Condition . OBJECTS_IN_AREA # 5 Effect . PATROL # 19 1 2 3 4 5 6 7 # Checking the docs for EffectId.CHANGE_DIPLOMACY will show: \"\"\" Attributes for the **change_diplomacy** effect are: - diplomacy - player_source - player_target \"\"\"","title":"Conditions &amp; Effects"},{"location":"cheatsheets/datasets/#conditions-effects-lists","text":"Many conditions and effects have dropdown lists with options. These options are, like everything else, impossible to remember. That's why these datasets have been added: Names Explanation Example DiplomacyState Used in the Change Diplomacy effect and the Diplomacy State condition. DiplomacyState.ALLY Operation Used in many effects. Generally related to variables. Operation.MULTIPLY ButtonLocation * Used in the Change Research Location and Change Train Location effects. * ButtonLocation.r2c3 PanelLocation Used in the Display Instructions effect. PanelLocation.CENTER TimeUnit Used in the Display Timer effect. TimeUnit.YEARS VisibilityState Used in the Set Player Visibility effect. VisibilityState.EXPLORED DifficultyLevel Used in the Difficulty Level condition. DifficultyLevel.HARDEST TechnologyState Used in the Technology State condition. TechnologyState.RESEARCHING Comparison Used in many effects and conditions. Generally related to variables. Comparison.EQUAL ObjectAttribute Used in the Modify Attribute effect. ObjectAttribute.CARRY_CAPACITY Attribute Used in the Accumulate Attribute effect. Attribute.ALL_TECHS_ACHIEVED UnitAIAction Used in the Object has Action condition. UnitAIAction.ATTACK AttackStance Used in the Change Object Stance effect. AttackStance.AGGRESSIVE_STANCE ObjectType Used in every unit selection effect & condition. ObjectType.DOPPELGANGER ObjectClass Used in every unit selection effect & condition. ObjectClass.INFANTRY DamageClass Used in the Change Object Attack/Armour effects. DamageClass.SPEARMEN HeroStatusFlag * Can be used for changing the HERO_STATUS in ObjectAttribute . * HeroStatusFlag.HERO_REGENERATION Hotkey Can be used for changing the HOTKEY_ID in ObjectAttribute . Hotkey.SPACE BlastLevel Can be used for changing the BLAST_<>_LEVEL properties in ObjectAttribute . BlastLevel.NEARBY_UNITS TerrainRestrictions Can be used for changing the TERRAIN_RESTRICTION_ID in ObjectAttribute . TerrainRestrictions.LAND SmartProjectile Can be used for changing the ENABLE_SMART_PROJECTILES in ObjectAttribute . SmartProjectile.ENABLED ColorMood Used in the Change Color Mood effect. ColorMood.WINTER ObjectState Used in the Objects in area condition. ObjectState.DEAD ColorId Used in the player manager for setting the player color. ColorId.GREEN Civilization Used in the player manager for setting the player civilization. Civilization.MAYANS StartingAge Used in the player manager for setting the player starting age. StartingAge.FEUDAL_AGE SecondaryGameMode Used for setting the secondary victory conditions. SecondaryGameMode.SUDDEN_DEATH *: Means extra functionality listed below.","title":"Conditions &amp; Effects lists"},{"location":"cheatsheets/datasets/#buttonlocation","text":"1 ButtonLocation . row_col ( 1 , 3 ) # ButtonLocation.r1c3","title":"ButtonLocation"},{"location":"cheatsheets/datasets/#herostatusflag","text":"1 2 3 4 5 6 # Both have the same result hsf = HeroStatusFlag . CANNOT_BE_CONVERTED + HeroStatusFlag . DELETE_CONFIRMATION hsf = HeroStatusFlag . combine ( cannot_be_converted = True , delete_confirmation = True )","title":"HeroStatusFlag"},{"location":"cheatsheets/datasets/#general-usage-examples","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 trigger = trigger_manager . add_trigger ( \"Inform Betrayal!\" ) condition = trigger . new_condition . diplomacy_state ( quantity = DiplomacyState . ALLY , # <-- DiplomacyState dataset source_player = PlayerId . TWO , target_player = PlayerId . THREE ) effect = trigger . new_effect . display_instructions ( source_player = PlayerId . ONE , message = \"Spy: Your ally has betrayed you! He allied the enemy!\" , instruction_panel_position = PanelLocation . CENTER , # <-- PanelLocation dataset display_time = 10 )","title":"General usage examples:"},{"location":"cheatsheets/datasets/#unit-building-techs-etc","text":"The Units and Buildings datasets are very useful when adding units. They're also, together with the Tech dataset, very useful when adding or editing triggers.","title":"Unit, Building, Techs etc."},{"location":"cheatsheets/datasets/#general-usage","text":"These are the biggest datasets and most powerful datasets: Dataset Description UnitInfo Dataset for units BuildingInfo Dataset for buildings HeroInfo Dataset for heroes OtherInfo Dataset for other units (like relics and gold piles) TechInfo Dataset for technologies For adding units it'll look something like the following: 1 2 3 4 5 unit_manager . add_unit ( PlayerId . ONE , UnitInfo . CONQUISTADOR . ID , x = 10 , y = 20 ) unit_manager . add_unit ( PlayerId . TWO , UnitInfo . PALADIN . ID , x = 20 , y = 20 ) unit_manager . add_unit ( PlayerId . GAIA , BuildingInfo . FEITORIA . ID , x = 30 , y = 20 ) unit_manager . add_unit ( PlayerId . GAIA , HeroInfo . WILLIAM_WALLACE . ID , x = 40 , y = 20 ) unit_manager . add_unit ( PlayerId . GAIA , OtherInfo . GOLD_MINE . ID , x = 50 , y = 20 ) With the triggers you can do similar stuff like: 1 2 3 4 5 6 7 8 9 10 ... effect = trigger . new_effect . create_object ( object_list_unit_id = OtherInfo . RELIC . ID ) ... effect = trigger . new_effect . research_technology ( source_player = PlayerId . THREE , technology = TechInfo . BLOODLINES . ID ) ...","title":"General Usage"},{"location":"cheatsheets/datasets/#unitinfo-functions","text":"Some useful functions for the UnitInfo dataset is vils() and unique_units() 1 2 3 4 5 6 # Get all villager units (e.g. FARMER, HUNTER, LUMBERJACK etc.) # You can disable certain categories like: # - exclude_male # - exclude_female # Example: male_vils = UnitInfo . vils ( exclude_female = True ) 1 2 3 4 5 6 7 8 # Get all unique units (e.g. HUSKARL, CONQUISTADOR, LONGBOAT, SLINGER etc.) # You can disable certain categories like: # - exclude_elite_units # - exclude_non_elite_units # - exclude_castle_units (From the castle building) # - exclude_non_castle_units (From anything but the castle building) # Example: all_unique_non_castle_non_elite_units = UnitInfo . unique_units ( exclude_elite_units = True , exclude_castle_units = True )","title":"UnitInfo functions"},{"location":"cheatsheets/datasets/#techinfo-functions","text":"Some useful functions for the TechInfo dataset are: unique_techs() 1 2 3 4 5 6 # Get all unique techs (e.g. BEARDED_AXE, CHIEFTAINS, FIRST_CRUSADE etc.) # You can disable certain categories like: # - exclude_castle_techs # - exclude_imp_techs # Example: imp_unique_techs = TechInfo . unique_techs ( exclude_castle_techs = True ) unique_unit_upgrades() 1 2 3 4 5 6 # Get all unique unit techs (e.g. ELITE_LONGBOWMAN, ELITE_TEUTONIC_KNIGHT etc.) # You can disable certain categories like: # - exclude_castle_techs # - exclude_non_castle_techs (Excludes stuff like: ELITE_LONGBOAT, IMPERIAL_SKIRMISHER) # Example: uu_castle_upgrades = TechInfo . unique_unit_upgrades ( exclude_non_castle_techs = True ) blacksmith_techs() monastery_techs() university_techs() town_center_techs() 1 2 3 4 5 6 7 8 9 # Get all blacksmith/monastery/university techs # You can filter on ages, like so: all_blacksmith_techs = TechInfo . blacksmith_techs () feudal_blacksmith_techs = TechInfo . blacksmith_techs ( Age . FEUDAL_AGE ) non_imp_blacksmith_techs = TechInfo . blacksmith_techs ([ Age . FEUDAL_AGE , Age . CASTLE_AGE ]) # Same goes for: # - TechInfo.monastery_techs(...) # - TechInfo.university_techs(...) # - TechInfo.town_center_techs(...) eco_techs() 1 2 3 4 5 6 7 8 9 10 11 12 13 # Get all economic techs all_eco_techs = TechInfo . eco_techs () # You can filter on ages (like with blacksmith_techs etc.): dark_age_eco_techs = TechInfo . eco_techs ( ages = Age . DARK_AGE ) # Only returns LOOM # Or filter on buildings mining_and_lumber_upgrades = TechInfo . eco_techs ( buildings = [ BuildingInfo . MINING_CAMP . ID , BuildingInfo . LUMBER_CAMP . ID ] ) # Or both: imp_tc_upgrades = TechInfo . eco_techs ( ages = Age . IMPERIAL_AGE , buildings = BuildingInfo . TOWN_CENTER . ID , )","title":"TechInfo functions"},{"location":"cheatsheets/datasets/#otherinfo-functions","text":"One useful function for the OtherInfo dataset is trees() : 1 2 3 # Get all tree objects (e.g. OAK_TREE, PINE_TREE, BAMBOO etc.) # Example: all_trees = OtherInfo . trees ()","title":"OtherInfo functions"},{"location":"cheatsheets/datasets/#icon-dead-hotkey-ids","text":"Besides normal IDs, you might want to access their icon or dead version. Almost every unit, building, hero and tech has an icon. Most units, buildings and heroes also have a dead unit version to represent the dying animation. You can access these values using the same datasets: 1 2 3 4 5 6 7 8 9 10 11 12 13 archer_id = UnitInfo . ARCHER . ID # 4 archer_icon = UnitInfo . ARCHER . ICON_ID # 17 archer_death = UnitInfo . ARCHER . DEAD_ID # 3 archer_hotkey_id = UnitInfo . ARCHER . HOTKEY_ID # 16083 # You can also get the datasets from these values UnitInfo . from_id ( 4 ) # UnitInfo.ARCHER UnitInfo . from_icon_id ( 17 ) # UnitInfo.ARCHER UnitInfo . from_dead_id ( 3 ) # UnitInfo.ARCHER UnitInfo . from_hotkey_id ( 16083 ) # UnitInfo.ARCHER # It's also still possible to use the string like normal enums: UnitInfo [ \"ARCHER\" ] # UnitInfo.ARCHER","title":"Icon, Dead &amp; Hotkey IDs"},{"location":"cheatsheets/datasets/#gaia","text":"If you want to know if a unit etc. is a gaia only object, you can do: 1 2 3 4 5 6 UnitInfo . ARCHER . IS_GAIA_ONLY # False UnitInfo . WOLF . IS_GAIA_ONLY # True # Or for a list: UnitInfo . gaia_only () # Returns all units which have 'IS_GAIA_ONLY' as True UnitInfo . non_gaia () # Returns all units which have 'IS_GAIA_ONLY' as False","title":"GAIA"},{"location":"cheatsheets/datasets/#projectiles","text":"If you wanted to change a projectile of archers to that of an arambai, you could do: 1 2 3 4 5 6 7 trigger . new_effect . modify_attribute ( quantity = ProjectileInfo . ARAMBAI . ID , object_list_unit_id = UnitInfo . ARCHER . ID , source_player = PlayerId . ONE , operation = Operation . SET , object_attributes = ObjectAttribute . PROJECTILE_UNIT ) Not all projectiles have the most obvious names. So you can use the following to find projectiles easier. 1 2 # Get the second projectile that a CHU KO NU shoots. (Pre-chemistry arrows) ProjectileInfo . get_unit_projectile ( UnitInfo . CHU_KO_NU . ID , has_chemistry = False , secondary = True )","title":"Projectiles"},{"location":"cheatsheets/datasets/#terrains","text":"The terrain dataset can be used for changing terrain types. 1 2 3 4 5 6 TerrainId . BEACH # 2 TerrainId . FOREST_OAK # 10 TerrainId . UNDERBUSH_LEAVES # 71 # Changing the terrain could be done like so: map_manager . terrain [ 0 ] . terrain_id = TerrainId . GRASS_1","title":"Terrains"},{"location":"cheatsheets/datasets/#players","text":"For selecting players it can be as easy as typing 1 . Unfortunately not all parts of the scenario file are structured like: 0: Gaia, 1: Player1 ... 8: Player8 . So because of this a representation layer has been added. It's a simple Enum which looks like this: 1 2 3 PlayerId . GAIA , PlayerId . ONE , PlayerId . TWO , PlayerId . THREE , PlayerId . FOUR , PlayerId . FIVE , PlayerId . SIX , PlayerId . SEVEN , PlayerId . EIGHT If you want to loop through players, you have 2 options: 1 2 3 4 5 6 7 # Python built-in range function: for player in range ( 9 ): # Or range(1, 9) if you want to exclude GAIA # ... code... # The PlayerId function: for player in PlayerId . all (): # Or PlayerId.all(exclude_gaia=True) if you want to exclude GAIA # ... code... You can also address the players by color if you prefer it: 1 2 PlayerColorId . BLUE , PlayerColorId . RED , PlayerColorId . GREEN , PlayerColorId . YELLOW , PlayerColorId . AQUA , PlayerColorId . PURPLE , PlayerColorId . GRAY , PlayerColorId . ORANGE","title":"Players"},{"location":"cheatsheets/map/","text":"Map \u00b6 You can use the map manager to adjust the terrain, elevation, map size and other attributes. Map Size \u00b6 You can adjust the map size using the parser. Only rectangular maps The game only supports square maps. Changing the size to a rectangle that is not a square will cause the game to crash. Maximum size is 480 The game does not support maps over the size of 480. Beyond this size the game will crash when you test the scenario. You can adjust the map size like so: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from AoE2ScenarioParser.scenarios.aoe2_de_scenario import AoE2DEScenario # File & Folder setup # Define paths to the scenario folder. # You can find this folder by opening AoE2:DE and going to scenarios and clicking on 'open folder' scenario_folder = \"your/path/to/the/scenario/folder/\" # <-- Final slash is important scenario_name = \"name_of_your_scenario\" # Define Scenario file scenario = AoE2DEScenario . from_file ( f \" { scenario_folder }{ scenario_name } .aoe2scenario\" ) # Add Trigger map_manager = scenario . map_manager # Set it to a nice small 10x10 map :) map_manager . map_size = 10 # Write to same folder with name + '_output' scenario . write_to_file ( f \" { scenario_folder }{ scenario_name } _output.aoe2scenario\" ) Terrain \u00b6 You can also edit terrain tiles. Terrain Tiles \u00b6 Each terrain tile has 3 properties. It's elevation , terrain_id and layer . You can request this information using: 1 2 3 4 tile = map_manager . get_tile ( 0 , 0 ) tile . terrain_id tile . elevation tile . layer You can also edit this information, for example if you want to change tile 20 into water, you can: 1 2 3 4 from AoE2ScenarioParser.datasets.terrains import TerrainId tile = map_manager . get_tile ( i = 19 ) # (0 based, 0 is the 1st tile, 1 is the second tile etc.) tile . terrain_id = TerrainId . WATER_SHALLOW You can also request readonly properties from a tile, like its index or coordinates. These cannot be edited. 1 2 3 4 5 tile = map_manager . get_tile ( 0 , 0 ) tile . i # 85 (Same tile as when you do: map_manager.terrain[85]) tile . x # 5 tile . y # 8 tile . xy # (5, 8) <-- Tuple(5,8) Selection \u00b6 There's multiple ways to get access to the terrain tiles. The first thing you can do is get access to the entire terrain list through: 1 map_manager.terrain # Returns a one dimensional list of TerrainTile objects The list is the map stacked in a single list. The first entry in the list is the most West tile in the scenario. The second entry is the tile to the top right of the last one. The third is on the top right of that one. This continues until you hit the North East edge. Then it'll continue with the tile to the bottom right of the first tile and the tile after that is the tile to the top right of it. Below you can see a visualisation of a 10x10 map. The coords are (X,Y) coordinates and the blue line is the order in which tiles are saved. To get a tile based on it's XY coordinate (like (5,8) , as highlighted in the above image) you can use: 1 2 map_manager . get_tile ( x = 5 , y = 8 ) # Get tile at x5,y8 map_manager . get_tile ( i = 85 ) # Get the 86th tile (0 based, 0 is the 1st tile, 1 is the second tile etc.) You can also get a square of tiles from the map. For this you can use the function get_square_1d() or get_square_2d() . Both the functions will return the same tiles, but one will result in a list of tiles, the other in a list of list with tiles. For example, if you want to turn a square of tiles into roads: 1 2 3 4 5 6 7 8 9 10 from AoE2ScenarioParser.datasets.terrains import TerrainId # Using: get_square_1d for tile in map_manager . get_square_1d ( x1 = 4 , y1 = 4 , x2 = 8 , y2 = 8 ): tile . terrain_id = TerrainId . ROAD # Using: get_square_2d for tile_row in map_manager . get_square_2d ( x1 = 4 , y1 = 4 , x2 = 8 , y2 = 8 ): for tile in tile_row : tile . terrain_id = TerrainId . ROAD This will turn the above map into: Elevation \u00b6 You can also add hills to the map by using the set_elevation function. 1 2 3 4 5 6 7 map_manager . set_elevation ( elevation = 2 , x1 = 3 , y1 = 3 , x2 = 5 , y2 = 5 , ) Elevation is also zero based Elevation is zero based, 0 represents what Age2 calls elevation 1, 1 represents elevation 2 etc. This will create a hill of elevation 3 in the game. The top square of the hill will be 3x3 tiles. Because (3,3) to (5,5) shown in the function above represents the top of the hill. The entire hill, including the slopes, will start on: (1,1) to (7,7). Don't go too high! Using the parser you can basically go as high as you want, BUT above ~20 without UHD and ~15 with UHD the camera starts clipping into the hill.","title":"Map"},{"location":"cheatsheets/map/#map","text":"You can use the map manager to adjust the terrain, elevation, map size and other attributes.","title":"Map"},{"location":"cheatsheets/map/#map-size","text":"You can adjust the map size using the parser. Only rectangular maps The game only supports square maps. Changing the size to a rectangle that is not a square will cause the game to crash. Maximum size is 480 The game does not support maps over the size of 480. Beyond this size the game will crash when you test the scenario. You can adjust the map size like so: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from AoE2ScenarioParser.scenarios.aoe2_de_scenario import AoE2DEScenario # File & Folder setup # Define paths to the scenario folder. # You can find this folder by opening AoE2:DE and going to scenarios and clicking on 'open folder' scenario_folder = \"your/path/to/the/scenario/folder/\" # <-- Final slash is important scenario_name = \"name_of_your_scenario\" # Define Scenario file scenario = AoE2DEScenario . from_file ( f \" { scenario_folder }{ scenario_name } .aoe2scenario\" ) # Add Trigger map_manager = scenario . map_manager # Set it to a nice small 10x10 map :) map_manager . map_size = 10 # Write to same folder with name + '_output' scenario . write_to_file ( f \" { scenario_folder }{ scenario_name } _output.aoe2scenario\" )","title":"Map Size"},{"location":"cheatsheets/map/#terrain","text":"You can also edit terrain tiles.","title":"Terrain"},{"location":"cheatsheets/map/#terrain-tiles","text":"Each terrain tile has 3 properties. It's elevation , terrain_id and layer . You can request this information using: 1 2 3 4 tile = map_manager . get_tile ( 0 , 0 ) tile . terrain_id tile . elevation tile . layer You can also edit this information, for example if you want to change tile 20 into water, you can: 1 2 3 4 from AoE2ScenarioParser.datasets.terrains import TerrainId tile = map_manager . get_tile ( i = 19 ) # (0 based, 0 is the 1st tile, 1 is the second tile etc.) tile . terrain_id = TerrainId . WATER_SHALLOW You can also request readonly properties from a tile, like its index or coordinates. These cannot be edited. 1 2 3 4 5 tile = map_manager . get_tile ( 0 , 0 ) tile . i # 85 (Same tile as when you do: map_manager.terrain[85]) tile . x # 5 tile . y # 8 tile . xy # (5, 8) <-- Tuple(5,8)","title":"Terrain Tiles"},{"location":"cheatsheets/map/#selection","text":"There's multiple ways to get access to the terrain tiles. The first thing you can do is get access to the entire terrain list through: 1 map_manager.terrain # Returns a one dimensional list of TerrainTile objects The list is the map stacked in a single list. The first entry in the list is the most West tile in the scenario. The second entry is the tile to the top right of the last one. The third is on the top right of that one. This continues until you hit the North East edge. Then it'll continue with the tile to the bottom right of the first tile and the tile after that is the tile to the top right of it. Below you can see a visualisation of a 10x10 map. The coords are (X,Y) coordinates and the blue line is the order in which tiles are saved. To get a tile based on it's XY coordinate (like (5,8) , as highlighted in the above image) you can use: 1 2 map_manager . get_tile ( x = 5 , y = 8 ) # Get tile at x5,y8 map_manager . get_tile ( i = 85 ) # Get the 86th tile (0 based, 0 is the 1st tile, 1 is the second tile etc.) You can also get a square of tiles from the map. For this you can use the function get_square_1d() or get_square_2d() . Both the functions will return the same tiles, but one will result in a list of tiles, the other in a list of list with tiles. For example, if you want to turn a square of tiles into roads: 1 2 3 4 5 6 7 8 9 10 from AoE2ScenarioParser.datasets.terrains import TerrainId # Using: get_square_1d for tile in map_manager . get_square_1d ( x1 = 4 , y1 = 4 , x2 = 8 , y2 = 8 ): tile . terrain_id = TerrainId . ROAD # Using: get_square_2d for tile_row in map_manager . get_square_2d ( x1 = 4 , y1 = 4 , x2 = 8 , y2 = 8 ): for tile in tile_row : tile . terrain_id = TerrainId . ROAD This will turn the above map into:","title":"Selection"},{"location":"cheatsheets/map/#elevation","text":"You can also add hills to the map by using the set_elevation function. 1 2 3 4 5 6 7 map_manager . set_elevation ( elevation = 2 , x1 = 3 , y1 = 3 , x2 = 5 , y2 = 5 , ) Elevation is also zero based Elevation is zero based, 0 represents what Age2 calls elevation 1, 1 represents elevation 2 etc. This will create a hill of elevation 3 in the game. The top square of the hill will be 3x3 tiles. Because (3,3) to (5,5) shown in the function above represents the top of the hill. The entire hill, including the slopes, will start on: (1,1) to (7,7). Don't go too high! Using the parser you can basically go as high as you want, BUT above ~20 without UHD and ~15 with UHD the camera starts clipping into the hill.","title":"Elevation"},{"location":"cheatsheets/players/","text":"Players \u00b6 You can use the player manager to edit many player related attributes. Editing \u00b6 Here's an example of how to view a player and edit their starting civilization, architecture and resources. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from AoE2ScenarioParser.scenarios.aoe2_de_scenario import AoE2DEScenario from AoE2ScenarioParser.datasets.object_support import Civilization from AoE2ScenarioParser.datasets.players import PlayerId # File & Folder setup # Define paths to the scenario folder. # You can find this folder by opening AoE2:DE and going to scenarios and clicking on 'open folder' scenario_folder = \"your/path/to/the/scenario/folder/\" # <-- Final slash is important scenario_name = \"name_of_your_scenario\" # Define Scenario file scenario = AoE2DEScenario . from_file ( f \" { scenario_folder }{ scenario_name } .aoe2scenario\" ) # Save the player manager and the second player player_manager = scenario . player_manager player_two = player_manager . players [ PlayerId . TWO ] player_two . civilization = Civilization . BYZANTINES player_two . architecture_set = Civilization . BYZANTINES player_two . food = 550 player_two . wood = 450 player_two . gold = 350 player_two . stone = 250 # Write to same folder with name + '_output' scenario . write_to_file ( f \" { scenario_folder }{ scenario_name } _output.aoe2scenario\" ) Players have many attributes, below is a list of most of their attributes which you can change. Attribute name Type Dataset Attributes player_id int - Read only active bool - Read only starting_age int StartingAge lock_civ bool - population_cap int - food int - wood int - gold int - stone int - color int ColorId human bool - civilization int Civilization architecture_set int Civilization diplomacy List[int] - Non-GAIA initial_camera_x int - Non-GAIA initial_camera_y int - Non-GAIA allied_victory bool - Non-GAIA disabled_techs List[int] - Non-GAIA disabled_buildings List[int] - Non-GAIA disabled_units List[int] - Non-GAIA tribe_name str - Non-GAIA base_priority int - Non-GAIA string_table_name_id int - Non-GAIA Active Players \u00b6 You can also set the active players with the player manager. Unfortunately, the game does not support enabling players in 'gaps'. If you want p4 enabled, you need to have p1, p2 and p3 enabled. This is why the 'active' attribute in the player object is read-only. You can set the active player like: 1 player_manager . active_players = 4 # Enables player 1, 2, 3 and 4 Disables \u00b6 Disables are used to disable units, buildings and technologies for a certain player. For example, if you want to disable archery ranges , stables and siege workshops for player two, and you want to disable the market , the tech loom and Paladins for the fifth player, you can do so like this: 1 2 3 4 5 6 7 8 9 10 11 player_two = player_manager . players [ PlayerId . TWO ] player_two . disabled_buildings . extend ([ BuildingInfo . ARCHERY_RANGE . ID , BuildingInfo . STABLE . ID , BuildingInfo . SIEGE_WORKSHOP . ID ]) player_five = player_manager . players [ PlayerId . FIVE ] player_five . disabled_buildings . append ( BuildingInfo . MARKET . ID ) player_five . disabled_techs . append ( TechInfo . LOOM . ID ) player_five . disabled_units . append ( UnitInfo . PALADIN . ID ) You can also copy the list of units from one player to another: 1 2 3 4 player_two = player_manager . players [ PlayerId . TWO ] player_five = player_manager . players [ PlayerId . FIVE ] player_five . disabled_buildings = player_two . disabled_buildings . copy () Diplomacy \u00b6 You can set diplomacy through the player manager or directly per player. Set diplomacy teams \u00b6 If you want to quickly set the diplomacy in teams where everyone is allied to the rest of the team, you can use the player_manager.set_diplomacy_teams function. It accepts a list of lists with integers or PlayerId numbers. The code below creates four teams of two. This sets the players to ally as you can see with the final diplomacy argument. 1 2 3 4 player_manager . set_diplomacy_teams ( [ 1 , 2 ], [ 3 , 4 ], [ 5 , 6 ], [ 7 , 8 ], diplomacy = DiplomacyState . ALLY ) Set diplomacy directly \u00b6 You can also set the diplomacy directly for a single player. For example, below you can see that player one is set to enemy with player 5 and player 2, 3 and 4 are set to ally. This is not mutual! These function calls will only set the diplomacy one-way. All 'target' players (2, 3, 4 and 5) are still on the default Enemy stance. 1 2 3 p1 = player_manager . players [ PlayerId . ONE ] p1 . set_player_diplomacy ( 5 , DiplomacyState . ENEMY ) p1 . set_player_diplomacy ([ 2 , 3 , 4 ], DiplomacyState . ALLY )","title":"Players"},{"location":"cheatsheets/players/#players","text":"You can use the player manager to edit many player related attributes.","title":"Players"},{"location":"cheatsheets/players/#editing","text":"Here's an example of how to view a player and edit their starting civilization, architecture and resources. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from AoE2ScenarioParser.scenarios.aoe2_de_scenario import AoE2DEScenario from AoE2ScenarioParser.datasets.object_support import Civilization from AoE2ScenarioParser.datasets.players import PlayerId # File & Folder setup # Define paths to the scenario folder. # You can find this folder by opening AoE2:DE and going to scenarios and clicking on 'open folder' scenario_folder = \"your/path/to/the/scenario/folder/\" # <-- Final slash is important scenario_name = \"name_of_your_scenario\" # Define Scenario file scenario = AoE2DEScenario . from_file ( f \" { scenario_folder }{ scenario_name } .aoe2scenario\" ) # Save the player manager and the second player player_manager = scenario . player_manager player_two = player_manager . players [ PlayerId . TWO ] player_two . civilization = Civilization . BYZANTINES player_two . architecture_set = Civilization . BYZANTINES player_two . food = 550 player_two . wood = 450 player_two . gold = 350 player_two . stone = 250 # Write to same folder with name + '_output' scenario . write_to_file ( f \" { scenario_folder }{ scenario_name } _output.aoe2scenario\" ) Players have many attributes, below is a list of most of their attributes which you can change. Attribute name Type Dataset Attributes player_id int - Read only active bool - Read only starting_age int StartingAge lock_civ bool - population_cap int - food int - wood int - gold int - stone int - color int ColorId human bool - civilization int Civilization architecture_set int Civilization diplomacy List[int] - Non-GAIA initial_camera_x int - Non-GAIA initial_camera_y int - Non-GAIA allied_victory bool - Non-GAIA disabled_techs List[int] - Non-GAIA disabled_buildings List[int] - Non-GAIA disabled_units List[int] - Non-GAIA tribe_name str - Non-GAIA base_priority int - Non-GAIA string_table_name_id int - Non-GAIA","title":"Editing"},{"location":"cheatsheets/players/#active-players","text":"You can also set the active players with the player manager. Unfortunately, the game does not support enabling players in 'gaps'. If you want p4 enabled, you need to have p1, p2 and p3 enabled. This is why the 'active' attribute in the player object is read-only. You can set the active player like: 1 player_manager . active_players = 4 # Enables player 1, 2, 3 and 4","title":"Active Players"},{"location":"cheatsheets/players/#disables","text":"Disables are used to disable units, buildings and technologies for a certain player. For example, if you want to disable archery ranges , stables and siege workshops for player two, and you want to disable the market , the tech loom and Paladins for the fifth player, you can do so like this: 1 2 3 4 5 6 7 8 9 10 11 player_two = player_manager . players [ PlayerId . TWO ] player_two . disabled_buildings . extend ([ BuildingInfo . ARCHERY_RANGE . ID , BuildingInfo . STABLE . ID , BuildingInfo . SIEGE_WORKSHOP . ID ]) player_five = player_manager . players [ PlayerId . FIVE ] player_five . disabled_buildings . append ( BuildingInfo . MARKET . ID ) player_five . disabled_techs . append ( TechInfo . LOOM . ID ) player_five . disabled_units . append ( UnitInfo . PALADIN . ID ) You can also copy the list of units from one player to another: 1 2 3 4 player_two = player_manager . players [ PlayerId . TWO ] player_five = player_manager . players [ PlayerId . FIVE ] player_five . disabled_buildings = player_two . disabled_buildings . copy ()","title":"Disables"},{"location":"cheatsheets/players/#diplomacy","text":"You can set diplomacy through the player manager or directly per player.","title":"Diplomacy"},{"location":"cheatsheets/players/#set-diplomacy-teams","text":"If you want to quickly set the diplomacy in teams where everyone is allied to the rest of the team, you can use the player_manager.set_diplomacy_teams function. It accepts a list of lists with integers or PlayerId numbers. The code below creates four teams of two. This sets the players to ally as you can see with the final diplomacy argument. 1 2 3 4 player_manager . set_diplomacy_teams ( [ 1 , 2 ], [ 3 , 4 ], [ 5 , 6 ], [ 7 , 8 ], diplomacy = DiplomacyState . ALLY )","title":"Set diplomacy teams"},{"location":"cheatsheets/players/#set-diplomacy-directly","text":"You can also set the diplomacy directly for a single player. For example, below you can see that player one is set to enemy with player 5 and player 2, 3 and 4 are set to ally. This is not mutual! These function calls will only set the diplomacy one-way. All 'target' players (2, 3, 4 and 5) are still on the default Enemy stance. 1 2 3 p1 = player_manager . players [ PlayerId . ONE ] p1 . set_player_diplomacy ( 5 , DiplomacyState . ENEMY ) p1 . set_player_diplomacy ([ 2 , 3 , 4 ], DiplomacyState . ALLY )","title":"Set diplomacy directly"},{"location":"cheatsheets/triggers/","text":"Triggers \u00b6 You can use the trigger manager to add, remove edit and view triggers and variables. Adding \u00b6 Here's an example of how to create (add) a trigger and add a condition and effect to it: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 from AoE2ScenarioParser.scenarios.aoe2_de_scenario import AoE2DEScenario from AoE2ScenarioParser.datasets.players import PlayerId from AoE2ScenarioParser.datasets.units import UnitInfo # File & Folder setup # Define paths to the scenario folder. # You can find this folder by opening AoE2:DE and going to scenarios and clicking on 'open folder' scenario_folder = \"your/path/to/the/scenario/folder/\" # <-- Final slash is important scenario_name = \"name_of_your_scenario\" # Define Scenario file scenario = AoE2DEScenario . from_file ( f \" { scenario_folder }{ scenario_name } .aoe2scenario\" ) # Add Trigger trigger_manager = scenario . trigger_manager trigger = trigger_manager . add_trigger ( \"Trigger Name Here\" ) # Add Timer Condition timer_condition = trigger . new_condition . timer ( timer = 20 ) # Add Create Object Effect create_paladin_effect = trigger . new_effect . create_object ( object_list_unit_id = UnitInfo . PALADIN . ID , source_player = PlayerId . ONE , location_x = 5 , location_y = 4 , ) # Write to same folder with name + '_output' scenario . write_to_file ( f \" { scenario_folder }{ scenario_name } _output.aoe2scenario\" ) Importing \u00b6 Instead of directly adding triggers you can also import triggers from another scenario: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from AoE2ScenarioParser.scenarios.aoe2_de_scenario import AoE2DEScenario # Define Scenario files source_scenario = AoE2DEScenario . from_file ( path_to_the_source_file ) target_scenario = AoE2DEScenario . from_file ( path_to_the_target_file ) # Define Trigger Managers source_trigger_manager = source_scenario . trigger_manager target_trigger_manager = target_scenario . trigger_manager # Import the triggers # In this case all triggers from the source scenario are copied # You can optionally set the index to which the imported triggers are set at # Leaving this out will add the imported triggers to the end of the target scenario # In the example below, the source triggers will be added BEFORE the target triggers due to the 0 target_trigger_manager . import_triggers ( source_trigger_manager . triggers , 0 ) target_scenario . write_to_file ( path_to_output_file ) Selecting \u00b6 Selecting a trigger can be done using the get_trigger function. The function accepts 1 argument, a TriggerSelect (Alias: TS ) object. You can import TS (or TriggerSelect ) like so: 1 2 from AoE2ScenarioParser.objects.support.trigger_select import TS from AoE2ScenarioParser.objects.support.trigger_select import TriggerSelect The constructor of TriggerSelect accepts 3 arguments, trigger_index , display_index and trigger . The trigger_index expects the trigger ID of a trigger. This is the a number related to the order of creation starting from 0. The display_index expects the display ID of a trigger. This is the a number related to the display order in the in-game editor. The trigger expects a trigger object. Read further below on how to create or select one. 1 2 3 4 5 6 7 8 9 10 11 TriggerSelect ( trigger_index =... ) TriggerSelect ( display_index =... ) TriggerSelect ( trigger =... ) # Use TS as alias & class methods: TS . index ( ... ) # Short hand for: trigger_index TS . display ( ... ) # Short hand for: display_index TS . trigger ( ... ) # Examples: trigger = trigger_manager . get_trigger ( TS . index ( 0 )) You can use the get_summary_as_string function to view these values without opening the in-game editor. The code below includes the code above: 1 2 3 4 5 6 7 8 9 10 print ( trigger_manager . get_summary_as_string ()) # Results in: \"\"\" Trigger Summary: Trigger Name Here [Index: 0, Display: 0] (conditions: 1, effects: 1) Variables Summary: << No Variables >> \"\"\" As you can see, the trigger and display index can be seen in the [Index: x, Display: x] part. These are the numbers you can use to select triggers. Which would look like: 1 2 3 4 5 6 # Define Scenario file scenario = AoE2DEScenario . from_file ( read_file ) # Get Trigger trigger_manager = scenario . trigger_manager trigger = trigger_manager . get_trigger ( TS . index ( 0 )) If you want to see the contents of the trigger you can do so by running the get_content_as_string function. This will result in the following (with the create trigger code): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 print ( trigger_manager . get_content_as_string ()) # Results in: \"\"\" Triggers: 'Trigger Name Here' [Index: 0, Display: 0]: enabled: True looping: False conditions: timer [Index: 0, Display: 0]: timer: 20 inverted: 0 effects: create_object [Index: 0, Display: 0]: object_list_unit_id: UnitInfo.PALADIN.ID source_player: PlayerId.ONE location_x: 5 location_y: 4 facet: 0 Variables: <<No Variables>> \"\"\" Editing \u00b6 When opening a file that already contains triggers you might want to edit or even remove said triggers. You can edit a trigger like so: 1 2 3 4 5 6 # Get the trigger_index or display_index using the content or summary methods above trigger = trigger_manager . get_trigger ( TS . index ( 0 )) trigger = trigger_manager . get_trigger ( TS . display ( 0 )) trigger . name = \"New Trigger Name\" trigger . description = \"Awesome New Description!\" Copy \u00b6 Pretty simple and straigtforward. It copies a trigger adding it at the end of the trigger list. Selecting a trigger is done using the standard trigger_index, display_index and trigger reference. You can use it as follows: 1 copied_trigger = trigger_manager . copy_trigger ( TS . index ( 0 )) This will result in a full (deep)copy of your trigger. The only parts that are edited are its id and the name (added \" (copy)\" ). Copy per player \u00b6 Just like the copy_trigger function, this trigger makes a (deep) copy of the given function. But, while copying, it'll change the everything player related. With this function comes great control. Below the usage is shown: 1 2 3 4 5 6 7 8 copied_triggers = trigger_manager . copy_trigger_per_player ( from_player = PlayerId . ONE , trigger_select = TS . index ( 0 ), create_copy_for_players = [ PlayerId . TWO , PlayerId . THREE , PlayerId . FOUR # Optional list ] ) print ( f \"New trigger for Player Two: { copied_triggers [ PlayerId . TWO ] } \" ) Copy tree \u00b6 This function copies the given trigger and all that are linked to this one. The function searches all effects in the given trigger and selects all triggers linked to it. It gets all triggers by taking the ids from (de)activate trigger effects. This will result in the entire tree being copied: 1 trigger_manager . copy_trigger_tree ( TS . index ( 0 )) Copy tree per player \u00b6 A combination of the copy_trigger_per_player and copy_trigger_tree functions. This function copies the entire tree per player. Besides the parameters that can be given to copy_trigger_per_player function, an additional group_triggers_by parameter is included. This way you can select in which order all the new triggers should be placed: 1 2 3 4 5 trigger_manager . copy_trigger_tree_per_player ( from_player = PlayerId . ONE , trigger_select = TS . index ( 0 ), group_triggers_by = GroupBy . PLAYER , # Other options: GroupBy.NONE and GroupBy.TRIGGER ) Removing \u00b6 When removing a trigger you can select it the same way as when getting a trigger using the get_trigger function. But on top of that you can also use it's reference: 1 2 3 trigger_manager . remove_trigger ( TS . index ( 0 )) trigger_manager . remove_trigger ( TS . display ( 0 )) trigger_manager . remove_trigger ( TS . trigger ( trigger )) For removing effects and conditions it's very similiar but the functions are accessed from the triggers themselves instead of the trigger_manager. You can select the effect or condition you want to remove using: it's index (the order by time of creation) display index (the order like the in-game editor) reference (the reference to that effect/condition object) 1 2 3 4 5 6 7 8 trigger = trigger_manager . get_trigger ( 0 ) trigger . remove_effect ( effect_index = 0 ) trigger . remove_effect ( display_index = 1 ) trigger . remove_effect ( effect = effect ) trigger . remove_condition ( condition_index = 0 ) trigger . remove_condition ( display_index = 1 ) trigger . remove_condition ( condition = condition )","title":"Triggers"},{"location":"cheatsheets/triggers/#triggers","text":"You can use the trigger manager to add, remove edit and view triggers and variables.","title":"Triggers"},{"location":"cheatsheets/triggers/#adding","text":"Here's an example of how to create (add) a trigger and add a condition and effect to it: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 from AoE2ScenarioParser.scenarios.aoe2_de_scenario import AoE2DEScenario from AoE2ScenarioParser.datasets.players import PlayerId from AoE2ScenarioParser.datasets.units import UnitInfo # File & Folder setup # Define paths to the scenario folder. # You can find this folder by opening AoE2:DE and going to scenarios and clicking on 'open folder' scenario_folder = \"your/path/to/the/scenario/folder/\" # <-- Final slash is important scenario_name = \"name_of_your_scenario\" # Define Scenario file scenario = AoE2DEScenario . from_file ( f \" { scenario_folder }{ scenario_name } .aoe2scenario\" ) # Add Trigger trigger_manager = scenario . trigger_manager trigger = trigger_manager . add_trigger ( \"Trigger Name Here\" ) # Add Timer Condition timer_condition = trigger . new_condition . timer ( timer = 20 ) # Add Create Object Effect create_paladin_effect = trigger . new_effect . create_object ( object_list_unit_id = UnitInfo . PALADIN . ID , source_player = PlayerId . ONE , location_x = 5 , location_y = 4 , ) # Write to same folder with name + '_output' scenario . write_to_file ( f \" { scenario_folder }{ scenario_name } _output.aoe2scenario\" )","title":"Adding"},{"location":"cheatsheets/triggers/#importing","text":"Instead of directly adding triggers you can also import triggers from another scenario: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from AoE2ScenarioParser.scenarios.aoe2_de_scenario import AoE2DEScenario # Define Scenario files source_scenario = AoE2DEScenario . from_file ( path_to_the_source_file ) target_scenario = AoE2DEScenario . from_file ( path_to_the_target_file ) # Define Trigger Managers source_trigger_manager = source_scenario . trigger_manager target_trigger_manager = target_scenario . trigger_manager # Import the triggers # In this case all triggers from the source scenario are copied # You can optionally set the index to which the imported triggers are set at # Leaving this out will add the imported triggers to the end of the target scenario # In the example below, the source triggers will be added BEFORE the target triggers due to the 0 target_trigger_manager . import_triggers ( source_trigger_manager . triggers , 0 ) target_scenario . write_to_file ( path_to_output_file )","title":"Importing"},{"location":"cheatsheets/triggers/#selecting","text":"Selecting a trigger can be done using the get_trigger function. The function accepts 1 argument, a TriggerSelect (Alias: TS ) object. You can import TS (or TriggerSelect ) like so: 1 2 from AoE2ScenarioParser.objects.support.trigger_select import TS from AoE2ScenarioParser.objects.support.trigger_select import TriggerSelect The constructor of TriggerSelect accepts 3 arguments, trigger_index , display_index and trigger . The trigger_index expects the trigger ID of a trigger. This is the a number related to the order of creation starting from 0. The display_index expects the display ID of a trigger. This is the a number related to the display order in the in-game editor. The trigger expects a trigger object. Read further below on how to create or select one. 1 2 3 4 5 6 7 8 9 10 11 TriggerSelect ( trigger_index =... ) TriggerSelect ( display_index =... ) TriggerSelect ( trigger =... ) # Use TS as alias & class methods: TS . index ( ... ) # Short hand for: trigger_index TS . display ( ... ) # Short hand for: display_index TS . trigger ( ... ) # Examples: trigger = trigger_manager . get_trigger ( TS . index ( 0 )) You can use the get_summary_as_string function to view these values without opening the in-game editor. The code below includes the code above: 1 2 3 4 5 6 7 8 9 10 print ( trigger_manager . get_summary_as_string ()) # Results in: \"\"\" Trigger Summary: Trigger Name Here [Index: 0, Display: 0] (conditions: 1, effects: 1) Variables Summary: << No Variables >> \"\"\" As you can see, the trigger and display index can be seen in the [Index: x, Display: x] part. These are the numbers you can use to select triggers. Which would look like: 1 2 3 4 5 6 # Define Scenario file scenario = AoE2DEScenario . from_file ( read_file ) # Get Trigger trigger_manager = scenario . trigger_manager trigger = trigger_manager . get_trigger ( TS . index ( 0 )) If you want to see the contents of the trigger you can do so by running the get_content_as_string function. This will result in the following (with the create trigger code): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 print ( trigger_manager . get_content_as_string ()) # Results in: \"\"\" Triggers: 'Trigger Name Here' [Index: 0, Display: 0]: enabled: True looping: False conditions: timer [Index: 0, Display: 0]: timer: 20 inverted: 0 effects: create_object [Index: 0, Display: 0]: object_list_unit_id: UnitInfo.PALADIN.ID source_player: PlayerId.ONE location_x: 5 location_y: 4 facet: 0 Variables: <<No Variables>> \"\"\"","title":"Selecting"},{"location":"cheatsheets/triggers/#editing","text":"When opening a file that already contains triggers you might want to edit or even remove said triggers. You can edit a trigger like so: 1 2 3 4 5 6 # Get the trigger_index or display_index using the content or summary methods above trigger = trigger_manager . get_trigger ( TS . index ( 0 )) trigger = trigger_manager . get_trigger ( TS . display ( 0 )) trigger . name = \"New Trigger Name\" trigger . description = \"Awesome New Description!\"","title":"Editing"},{"location":"cheatsheets/triggers/#copy","text":"Pretty simple and straigtforward. It copies a trigger adding it at the end of the trigger list. Selecting a trigger is done using the standard trigger_index, display_index and trigger reference. You can use it as follows: 1 copied_trigger = trigger_manager . copy_trigger ( TS . index ( 0 )) This will result in a full (deep)copy of your trigger. The only parts that are edited are its id and the name (added \" (copy)\" ).","title":"Copy"},{"location":"cheatsheets/triggers/#copy-per-player","text":"Just like the copy_trigger function, this trigger makes a (deep) copy of the given function. But, while copying, it'll change the everything player related. With this function comes great control. Below the usage is shown: 1 2 3 4 5 6 7 8 copied_triggers = trigger_manager . copy_trigger_per_player ( from_player = PlayerId . ONE , trigger_select = TS . index ( 0 ), create_copy_for_players = [ PlayerId . TWO , PlayerId . THREE , PlayerId . FOUR # Optional list ] ) print ( f \"New trigger for Player Two: { copied_triggers [ PlayerId . TWO ] } \" )","title":"Copy per player"},{"location":"cheatsheets/triggers/#copy-tree","text":"This function copies the given trigger and all that are linked to this one. The function searches all effects in the given trigger and selects all triggers linked to it. It gets all triggers by taking the ids from (de)activate trigger effects. This will result in the entire tree being copied: 1 trigger_manager . copy_trigger_tree ( TS . index ( 0 ))","title":"Copy tree"},{"location":"cheatsheets/triggers/#copy-tree-per-player","text":"A combination of the copy_trigger_per_player and copy_trigger_tree functions. This function copies the entire tree per player. Besides the parameters that can be given to copy_trigger_per_player function, an additional group_triggers_by parameter is included. This way you can select in which order all the new triggers should be placed: 1 2 3 4 5 trigger_manager . copy_trigger_tree_per_player ( from_player = PlayerId . ONE , trigger_select = TS . index ( 0 ), group_triggers_by = GroupBy . PLAYER , # Other options: GroupBy.NONE and GroupBy.TRIGGER )","title":"Copy tree per player"},{"location":"cheatsheets/triggers/#removing","text":"When removing a trigger you can select it the same way as when getting a trigger using the get_trigger function. But on top of that you can also use it's reference: 1 2 3 trigger_manager . remove_trigger ( TS . index ( 0 )) trigger_manager . remove_trigger ( TS . display ( 0 )) trigger_manager . remove_trigger ( TS . trigger ( trigger )) For removing effects and conditions it's very similiar but the functions are accessed from the triggers themselves instead of the trigger_manager. You can select the effect or condition you want to remove using: it's index (the order by time of creation) display index (the order like the in-game editor) reference (the reference to that effect/condition object) 1 2 3 4 5 6 7 8 trigger = trigger_manager . get_trigger ( 0 ) trigger . remove_effect ( effect_index = 0 ) trigger . remove_effect ( display_index = 1 ) trigger . remove_effect ( effect = effect ) trigger . remove_condition ( condition_index = 0 ) trigger . remove_condition ( display_index = 1 ) trigger . remove_condition ( condition = condition )","title":"Removing"},{"location":"cheatsheets/units/","text":"Units \u00b6 You can use the unit manager to add, edit and remove units. This includes buildings and heroes etc. Adding \u00b6 Below you can find examples on how to add units to the scenario. This will add a conquistador for player 1 at (0, 0) which is the West corner of the map: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 from AoE2ScenarioParser.datasets.players import PlayerId from AoE2ScenarioParser.datasets.units import UnitInfo # ... # Read scenario etc. # ... # Add Unit unit_manager = scenario . unit_manager unit = unit_manager . add_unit ( player = PlayerId . ONE , unit_const = UnitInfo . CONQUISTADOR . ID , # Units dataset x = 0.5 , y = 0.5 ) # Or, with more detail: unit = unit_manager . add_unit ( player = PlayerId . ONE , unit_const = UnitInfo . CONQUISTADOR . ID , x = 0.5 , y = 0.5 , z = 0 , # The 'height' of the unit. rotation = 0 , # Rotation in radians animation_frame = 0 , # The nth animation frame ) Selecting \u00b6 To select the units you want there are a couple options. You can select all the units from a certain player: 1 gaia_units = unit_manager . get_player_units ( PlayerId . GAIA ) Or, get all units: 1 all_units = unit_manager . get_all_units () If you want a more specific search, you can use the get_units_in_area function. This function is quite powerful. You can select an area using coordinates or using tiles. You can also use a whitelist of players or a blacklist of players to (not) select the units from. And, if you have, hand it your own list of units to filter through. You can see a couple examples below: 1 2 3 4 5 6 7 8 unit_manager . get_units_in_area ( x1 = 0 , y1 = 0 , x2 = 10 , y2 = 10 ) # Any unit within 0,0 => 10,10 unit_manager . get_units_in_area ( tile1 = Tile ( 0 , 0 ), tile2 = Tile ( 10 , 10 )) # Any unit within 0,0 => 11, 11 (Note the 11, 11) # This is because Tiles are squares (1x1). So: # >>> Tile(0,0).x1 == 0 # >>> Tile(0,0).x2 == 1 For all other examples we'll be using the [x, y] notation. But you can use the Tile notation interchangeably: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 unit_manager . get_units_in_area ( x1 = 2 , y1 = 3 , x2 = 4 , y2 = 5 , players = [ PlayerId . ONE , PlayerId . TWO ]) # Any unit within 2,3 => 4,5 from Player 1 and 2. unit_manager . get_units_in_area ( x1 = 2 , y1 = 3 , x2 = 4 , y2 = 5 , ignore_players = [ PlayerId . GAIA ]) # Any unit within 2,3 => 4,5 from any Player but GAIA. unit = unit_manager . add_unit ( player = PlayerId . ONE , unit_const = UnitInfo . CONQUISTADOR . ID , x = 5 , y = 1 ) unit2 = unit_manager . add_unit ( player = PlayerId . TWO , unit_const = UnitInfo . CONQUISTADOR . ID , x = 1 , y = 5 ) unit_manager . get_units_in_area ( x1 = 0 , y1 = 0 , x2 = 9 , y2 = 9 , unit_list = [ unit , unit2 ], players = [ PlayerId . ONE ]) # Selects any unit from the given list that belongs to Player 1 within 0,0 => 9,9. You can also filter certain units based on their unit_const value. For this you can use the filter_units_by_const function. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # Get TC object of all players unit_manager . filter_units_by_const ( unit_consts = [ BuildingInfo . TOWN_CENTER . ID ]) # Get TC object of only player one and two unit_manager . filter_units_by_const ( unit_consts = [ BuildingInfo . TOWN_CENTER . ID ], player_list = [ PlayerId . ONE , PlayerId . TWO ]) # Get all objects of player one except for the villagers unit_manager . filter_units_by_const ( unit_consts = [ UnitInfo . VILLAGER_MALE , UnitInfo . VILLAGER_FEMALE ], blacklist = True , # <-- When True, everything in the unit_consts list will be excluded instead of included player_list = [ PlayerId . ONE ], ) # Exclude all unique units from a given list unit_manager . filter_units_by_const ( unit_consts = UnitInfo . unique_units (), blacklist = True , unit_list = [ some_list_with_Unit_objects ] ) Editing \u00b6 While adding units is fun, you might want to change existing units. You can, for example, change the location of any unit: 1 2 3 4 5 6 7 8 from AoE2ScenarioParser.objects.support.tile import Tile ... unit . tile = Tile ( 0 , 0 ) # Will change the units location to the center of tile 0,0 # Equivelant to: unit . x = 0.5 unit . y = 0.5 Besides it's location you can also change the type of unit: 1 unit . unit_const = UnitInfo . MAN_AT_ARMS . ID # Units dataset You also might want to change the ownership of a unit. You can do this by changing the player property in the unit object itself or calling change_ownership from the unit manager. 1 2 3 # Both are identical in functionality unit . player = PlayerId . THREE unit_manager . change_ownership ( unit , PlayerId . THREE ) Removing \u00b6 Two ways to delete a unit: Removing a unit using an object is faster Due to a unit object containing the player value it belongs to, the unit can be found a lot faster. Which, when removing a lot of units, can save you some time. 1 2 unit_manager . remove_unit ( unit = unit ) unit_manager . remove_unit ( reference_id = unit . reference_id ) If you want to remove all units from the map or a single player you can also just set it to an empty list: 1 2 3 4 # Remove all units from P3 unit_manager . units [ PlayerId . THREE ] = [] # Remove all units unit_manager . units = [] Other functions \u00b6 Ever wanted to get rid of all the eye candy on the map? Now you can: 1 unit_manager . remove_eye_candy ()","title":"Units"},{"location":"cheatsheets/units/#units","text":"You can use the unit manager to add, edit and remove units. This includes buildings and heroes etc.","title":"Units"},{"location":"cheatsheets/units/#adding","text":"Below you can find examples on how to add units to the scenario. This will add a conquistador for player 1 at (0, 0) which is the West corner of the map: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 from AoE2ScenarioParser.datasets.players import PlayerId from AoE2ScenarioParser.datasets.units import UnitInfo # ... # Read scenario etc. # ... # Add Unit unit_manager = scenario . unit_manager unit = unit_manager . add_unit ( player = PlayerId . ONE , unit_const = UnitInfo . CONQUISTADOR . ID , # Units dataset x = 0.5 , y = 0.5 ) # Or, with more detail: unit = unit_manager . add_unit ( player = PlayerId . ONE , unit_const = UnitInfo . CONQUISTADOR . ID , x = 0.5 , y = 0.5 , z = 0 , # The 'height' of the unit. rotation = 0 , # Rotation in radians animation_frame = 0 , # The nth animation frame )","title":"Adding"},{"location":"cheatsheets/units/#selecting","text":"To select the units you want there are a couple options. You can select all the units from a certain player: 1 gaia_units = unit_manager . get_player_units ( PlayerId . GAIA ) Or, get all units: 1 all_units = unit_manager . get_all_units () If you want a more specific search, you can use the get_units_in_area function. This function is quite powerful. You can select an area using coordinates or using tiles. You can also use a whitelist of players or a blacklist of players to (not) select the units from. And, if you have, hand it your own list of units to filter through. You can see a couple examples below: 1 2 3 4 5 6 7 8 unit_manager . get_units_in_area ( x1 = 0 , y1 = 0 , x2 = 10 , y2 = 10 ) # Any unit within 0,0 => 10,10 unit_manager . get_units_in_area ( tile1 = Tile ( 0 , 0 ), tile2 = Tile ( 10 , 10 )) # Any unit within 0,0 => 11, 11 (Note the 11, 11) # This is because Tiles are squares (1x1). So: # >>> Tile(0,0).x1 == 0 # >>> Tile(0,0).x2 == 1 For all other examples we'll be using the [x, y] notation. But you can use the Tile notation interchangeably: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 unit_manager . get_units_in_area ( x1 = 2 , y1 = 3 , x2 = 4 , y2 = 5 , players = [ PlayerId . ONE , PlayerId . TWO ]) # Any unit within 2,3 => 4,5 from Player 1 and 2. unit_manager . get_units_in_area ( x1 = 2 , y1 = 3 , x2 = 4 , y2 = 5 , ignore_players = [ PlayerId . GAIA ]) # Any unit within 2,3 => 4,5 from any Player but GAIA. unit = unit_manager . add_unit ( player = PlayerId . ONE , unit_const = UnitInfo . CONQUISTADOR . ID , x = 5 , y = 1 ) unit2 = unit_manager . add_unit ( player = PlayerId . TWO , unit_const = UnitInfo . CONQUISTADOR . ID , x = 1 , y = 5 ) unit_manager . get_units_in_area ( x1 = 0 , y1 = 0 , x2 = 9 , y2 = 9 , unit_list = [ unit , unit2 ], players = [ PlayerId . ONE ]) # Selects any unit from the given list that belongs to Player 1 within 0,0 => 9,9. You can also filter certain units based on their unit_const value. For this you can use the filter_units_by_const function. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # Get TC object of all players unit_manager . filter_units_by_const ( unit_consts = [ BuildingInfo . TOWN_CENTER . ID ]) # Get TC object of only player one and two unit_manager . filter_units_by_const ( unit_consts = [ BuildingInfo . TOWN_CENTER . ID ], player_list = [ PlayerId . ONE , PlayerId . TWO ]) # Get all objects of player one except for the villagers unit_manager . filter_units_by_const ( unit_consts = [ UnitInfo . VILLAGER_MALE , UnitInfo . VILLAGER_FEMALE ], blacklist = True , # <-- When True, everything in the unit_consts list will be excluded instead of included player_list = [ PlayerId . ONE ], ) # Exclude all unique units from a given list unit_manager . filter_units_by_const ( unit_consts = UnitInfo . unique_units (), blacklist = True , unit_list = [ some_list_with_Unit_objects ] )","title":"Selecting"},{"location":"cheatsheets/units/#editing","text":"While adding units is fun, you might want to change existing units. You can, for example, change the location of any unit: 1 2 3 4 5 6 7 8 from AoE2ScenarioParser.objects.support.tile import Tile ... unit . tile = Tile ( 0 , 0 ) # Will change the units location to the center of tile 0,0 # Equivelant to: unit . x = 0.5 unit . y = 0.5 Besides it's location you can also change the type of unit: 1 unit . unit_const = UnitInfo . MAN_AT_ARMS . ID # Units dataset You also might want to change the ownership of a unit. You can do this by changing the player property in the unit object itself or calling change_ownership from the unit manager. 1 2 3 # Both are identical in functionality unit . player = PlayerId . THREE unit_manager . change_ownership ( unit , PlayerId . THREE )","title":"Editing"},{"location":"cheatsheets/units/#removing","text":"Two ways to delete a unit: Removing a unit using an object is faster Due to a unit object containing the player value it belongs to, the unit can be found a lot faster. Which, when removing a lot of units, can save you some time. 1 2 unit_manager . remove_unit ( unit = unit ) unit_manager . remove_unit ( reference_id = unit . reference_id ) If you want to remove all units from the map or a single player you can also just set it to an empty list: 1 2 3 4 # Remove all units from P3 unit_manager . units [ PlayerId . THREE ] = [] # Remove all units unit_manager . units = []","title":"Removing"},{"location":"cheatsheets/units/#other-functions","text":"Ever wanted to get rid of all the eye candy on the map? Now you can: 1 unit_manager . remove_eye_candy ()","title":"Other functions"},{"location":"cheatsheets/xs/","text":"XS Script \u00b6 For an introduction to the XS scripting language itself, you can check out the UGC Guide . Support \u00b6 As of writing this, Age of Empires 2 Definitive Edition does not support transferring XS scripts attached to a scenario through multiplayer lobbies. This results in an issue where you cannot use XS in multiplayer until everyone in the lobby places the XS file at the proper location by hand. Which is very cumbersome. To get around this, you can add your XS script to a Script Call effect. When you add the XS to such an effect, it will, when loading the scenario, move all scripts from those calls to the default0.xs file. This does work in multiplayer because it happens on every machine separately. So the XS support for the parser works with a dedicated trigger and a Script Call effect. In the in-game editor the amount of text in a Script Call effect is limited to a certain number of characters. This limitation can be bypassed using the parser. Initialising XS Trigger \u00b6 You can use the XS manager to add XS to your scenarios. All these XS calls do indeed transfer in multiplayer lobbies as is explained above. You can use the XS manager like so: 1 2 3 4 5 6 7 8 9 10 from AoE2ScenarioParser.scenarios.aoe2_de_scenario import AoE2DEScenario # File & Folder setup scenario_folder = \"your/path/to/the/scenario/folder/\" read_file = scenario_folder + \"scenario_name.aoe2scenario\" # Define Scenario file scenario = AoE2DEScenario . from_file ( read_file ) xs_manager = scenario . xs_manager Because the XS Manager uses a trigger with a Script Call in the background, it needs to place the trigger somewhere. You can call the function below to create the trigger. You can also give it an index to insert it somewhere in the scenario. Not adding an index to the call just adds the trigger at the end of the list. Warning Placing the trigger at the top of all triggers ( insert_index=0 ) can take quite a lot of time if the map already has a lot of triggers (For example over 1000 triggers). 1 2 3 xs_manager . initialise_xs_trigger () # Or place the XS trigger at the top of all triggers xs_manager . initialise_xs_trigger ( insert_index = 0 ) Adding XS \u00b6 You don't have to initialise the trigger Whenever you call the add_script() function, it will automatically initialise the trigger if it hasn't been already. The use of the initialise_xs_trigger() function is to control where the trigger is placed. You can add scripts to the trigger using the add_script function. This function accepts a path to an XS file and a direct XS script string. 1 2 3 4 5 6 7 8 9 10 # Add a file to the script. # Work on your XS script in a file and this will add it to the scenario xm . add_script ( xs_file_path = \"path/to/xs/script.xs\" ) # Add XS directly xs_script = \"\"\" int a = 1; int b = a + 4; \"\"\" xm . add_script ( xs_string = xs_script ) You can use both xs_file_path=... and xs_string=... in the same add_script call too.","title":"XS Script"},{"location":"cheatsheets/xs/#xs-script","text":"For an introduction to the XS scripting language itself, you can check out the UGC Guide .","title":"XS Script"},{"location":"cheatsheets/xs/#support","text":"As of writing this, Age of Empires 2 Definitive Edition does not support transferring XS scripts attached to a scenario through multiplayer lobbies. This results in an issue where you cannot use XS in multiplayer until everyone in the lobby places the XS file at the proper location by hand. Which is very cumbersome. To get around this, you can add your XS script to a Script Call effect. When you add the XS to such an effect, it will, when loading the scenario, move all scripts from those calls to the default0.xs file. This does work in multiplayer because it happens on every machine separately. So the XS support for the parser works with a dedicated trigger and a Script Call effect. In the in-game editor the amount of text in a Script Call effect is limited to a certain number of characters. This limitation can be bypassed using the parser.","title":"Support"},{"location":"cheatsheets/xs/#initialising-xs-trigger","text":"You can use the XS manager to add XS to your scenarios. All these XS calls do indeed transfer in multiplayer lobbies as is explained above. You can use the XS manager like so: 1 2 3 4 5 6 7 8 9 10 from AoE2ScenarioParser.scenarios.aoe2_de_scenario import AoE2DEScenario # File & Folder setup scenario_folder = \"your/path/to/the/scenario/folder/\" read_file = scenario_folder + \"scenario_name.aoe2scenario\" # Define Scenario file scenario = AoE2DEScenario . from_file ( read_file ) xs_manager = scenario . xs_manager Because the XS Manager uses a trigger with a Script Call in the background, it needs to place the trigger somewhere. You can call the function below to create the trigger. You can also give it an index to insert it somewhere in the scenario. Not adding an index to the call just adds the trigger at the end of the list. Warning Placing the trigger at the top of all triggers ( insert_index=0 ) can take quite a lot of time if the map already has a lot of triggers (For example over 1000 triggers). 1 2 3 xs_manager . initialise_xs_trigger () # Or place the XS trigger at the top of all triggers xs_manager . initialise_xs_trigger ( insert_index = 0 )","title":"Initialising XS Trigger"},{"location":"cheatsheets/xs/#adding-xs","text":"You don't have to initialise the trigger Whenever you call the add_script() function, it will automatically initialise the trigger if it hasn't been already. The use of the initialise_xs_trigger() function is to control where the trigger is placed. You can add scripts to the trigger using the add_script function. This function accepts a path to an XS file and a direct XS script string. 1 2 3 4 5 6 7 8 9 10 # Add a file to the script. # Work on your XS script in a file and this will add it to the scenario xm . add_script ( xs_file_path = \"path/to/xs/script.xs\" ) # Add XS directly xs_script = \"\"\" int a = 1; int b = a + 4; \"\"\" xm . add_script ( xs_string = xs_script ) You can use both xs_file_path=... and xs_string=... in the same add_script call too.","title":"Adding XS"},{"location":"examples/examples/","text":"Examples \u00b6 These pages show questions I've been asked and my answers to said questions. These examples might help you get the hang of it a little faster. I will expand the pages whenever I get more questions (and have time to add them). If you have any questions, and the docs don't answer them, feel free to send them my way! Check the support page for up-to-date contact info. For a Hello World example, check out the Hello World page here . It includes a complete code block example at the bottom of the page.","title":"Intro"},{"location":"examples/examples/#examples","text":"These pages show questions I've been asked and my answers to said questions. These examples might help you get the hang of it a little faster. I will expand the pages whenever I get more questions (and have time to add them). If you have any questions, and the docs don't answer them, feel free to send them my way! Check the support page for up-to-date contact info. For a Hello World example, check out the Hello World page here . It includes a complete code block example at the bottom of the page.","title":"Examples"},{"location":"examples/triggers/","text":"Trigger examples \u00b6 Replace all sound names with a specific name \u00b6 How to replace all sound names in effects with the name: OldName to NewName ? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # Import the scenario object from AoE2ScenarioParser.scenarios.aoe2_de_scenario import AoE2DEScenario # Define Scenario file scenario = AoE2DEScenario . from_file ( file_path_here ) trigger_manager = scenario . trigger_manager # Loop through all triggers for trigger in trigger_manager . triggers : # Loop through all effects in a trigger for effect in trigger . effects : # Check if the sound_name attribute is equal to \"OldName\" and replace it with \"NewName\" if effect . sound_name == \"OldName\" : effect . sound_name = \"NewName\" scenario . write_to_file ( file_output_path_here ) Importing all triggers from another scenario \u00b6 Get all triggers from one scenario and import them into another scenario. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from AoE2ScenarioParser.scenarios.aoe2_de_scenario import AoE2DEScenario # Define Scenario files source_scenario = AoE2DEScenario . from_file ( path_to_the_source_file ) target_scenario = AoE2DEScenario . from_file ( path_to_the_target_file ) # Define Trigger Managers source_trigger_manager = source_scenario . trigger_manager target_trigger_manager = target_scenario . trigger_manager # Import the triggers # In this case all triggers from the source scenario are copied # You can optionally set the index to which the imported triggers are set at # Leaving this out will add the imported triggers to the end of the target scenario # In the example below, the source triggers will be added BEFORE the target triggers due to the 0 target_trigger_manager . import_triggers ( source_trigger_manager . triggers , 0 ) target_scenario . write_to_file ( path_to_output_file )","title":"Triggers"},{"location":"examples/triggers/#trigger-examples","text":"","title":"Trigger examples"},{"location":"examples/triggers/#replace-all-sound-names-with-a-specific-name","text":"How to replace all sound names in effects with the name: OldName to NewName ? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # Import the scenario object from AoE2ScenarioParser.scenarios.aoe2_de_scenario import AoE2DEScenario # Define Scenario file scenario = AoE2DEScenario . from_file ( file_path_here ) trigger_manager = scenario . trigger_manager # Loop through all triggers for trigger in trigger_manager . triggers : # Loop through all effects in a trigger for effect in trigger . effects : # Check if the sound_name attribute is equal to \"OldName\" and replace it with \"NewName\" if effect . sound_name == \"OldName\" : effect . sound_name = \"NewName\" scenario . write_to_file ( file_output_path_here )","title":"Replace all sound names with a specific name"},{"location":"examples/triggers/#importing-all-triggers-from-another-scenario","text":"Get all triggers from one scenario and import them into another scenario. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from AoE2ScenarioParser.scenarios.aoe2_de_scenario import AoE2DEScenario # Define Scenario files source_scenario = AoE2DEScenario . from_file ( path_to_the_source_file ) target_scenario = AoE2DEScenario . from_file ( path_to_the_target_file ) # Define Trigger Managers source_trigger_manager = source_scenario . trigger_manager target_trigger_manager = target_scenario . trigger_manager # Import the triggers # In this case all triggers from the source scenario are copied # You can optionally set the index to which the imported triggers are set at # Leaving this out will add the imported triggers to the end of the target scenario # In the example below, the source triggers will be added BEFORE the target triggers due to the 0 target_trigger_manager . import_triggers ( source_trigger_manager . triggers , 0 ) target_scenario . write_to_file ( path_to_output_file )","title":"Importing all triggers from another scenario"}]}